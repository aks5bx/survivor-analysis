<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Survivor Voting Analysis</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f5;
            color: #333;
            overflow: hidden;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            background: #fff;
            border-bottom: 2px solid #e0e0e0;
            padding: 0 20px;
            padding-top: env(safe-area-inset-top, 0);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
            position: relative;
            z-index: 100;
        }

        .tab-nav::-webkit-scrollbar {
            display: none;
        }

        .tab-btn {
            padding: 14px 24px;
            border: none;
            background: none;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tab-btn:hover {
            color: #333;
            background: #f5f5f5;
        }

        .tab-btn.active {
            color: #d32f2f;
            border-bottom-color: #d32f2f;
        }

        /* Dropdown menu styles */
        .tab-dropdown {
            position: relative;
            display: inline-block;
        }

        .tab-dropdown-btn {
            padding: 12px 20px;
            border: none;
            background: none;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tab-dropdown-btn:hover {
            color: #333;
            background: #f5f5f5;
        }

        .tab-dropdown-btn.active {
            color: #d32f2f;
            border-bottom-color: #d32f2f;
        }

        .dropdown-arrow {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .tab-dropdown.open .dropdown-arrow {
            transform: rotate(180deg);
        }

        .dropdown-menu {
            display: none;
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 200px;
            z-index: 10000;
            margin-top: 2px;
        }

        .tab-dropdown.open .dropdown-menu {
            display: block;
        }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: none;
            text-align: left;
            font-size: 14px;
            color: #333;
            cursor: pointer;
            transition: background 0.2s;
        }

        .dropdown-item:hover {
            background: #f5f5f5;
        }

        .dropdown-item:first-child {
            border-radius: 4px 4px 0 0;
        }

        .dropdown-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        .dropdown-item.active {
            background: #fff3f3;
            color: #d32f2f;
            font-weight: 600;
        }

        .tab-content {
            display: none;
            height: calc(100vh - 50px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tab-content.active {
            display: block;
        }

        /* Vote Flow Tab - needs higher specificity to override display: block */
        #voteflow-tab.active {
            display: flex;
            overflow: hidden;
        }

        #main-viz {
            flex: 1;
            position: relative;
            background: #ffffff;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        #main-viz svg {
            flex-shrink: 0;
            min-height: 600px;
        }

        /* FTC Section Styles */
        #ftc-section {
            background: #fafafa;
            border-top: 2px solid #e0e0e0;
            padding: 20px 24px;
            flex-shrink: 0;
        }

        #ftc-section h2 {
            font-size: 18px;
            color: #d32f2f;
            margin-bottom: 16px;
        }

        .ftc-finalists {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .finalist-card {
            background: #fff;
            border-radius: 10px;
            padding: 12px 18px;
            text-align: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            min-width: 100px;
        }

        .finalist-card.winner {
            border: 2px solid #ffd700;
            background: linear-gradient(135deg, #fffef0 0%, #fff 100%);
        }

        .finalist-card .finalist-color {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin: 0 auto 8px;
            border: 2px solid rgba(0,0,0,0.1);
        }

        .finalist-card .finalist-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 2px;
        }

        .finalist-card .finalist-votes {
            color: #666;
            font-size: 12px;
        }

        .finalist-card .winner-badge {
            background: #ffd700;
            color: #333;
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 10px;
            margin-top: 6px;
            display: inline-block;
        }

        .ftc-table {
            width: 100%;
            background: #fff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }

        .ftc-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .ftc-table th,
        .ftc-table td {
            padding: 10px 14px;
            text-align: left;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }

        .ftc-table th {
            background: #f8f9fa;
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            color: #666;
            letter-spacing: 0.5px;
        }

        .ftc-table tr:last-child td {
            border-bottom: none;
        }

        .ftc-table tr:hover {
            background: #f8f9fa;
        }

        .juror-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .juror-cell .color-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            flex-shrink: 0;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .voted-for-cell {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .voted-for-cell .color-dot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            flex-shrink: 0;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .alignment-cell {
            font-weight: 500;
        }

        .alignment-cell.high {
            color: #2e7d32;
        }

        .alignment-cell.medium {
            color: #f57c00;
        }

        .alignment-cell.low {
            color: #d32f2f;
        }

        .eliminated-by {
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 500;
        }

        .eliminated-by.yes {
            background: #ffebee;
            color: #c62828;
        }

        .eliminated-by.no {
            background: #e8f5e9;
            color: #2e7d32;
        }

        #sidebar {
            width: 220px;
            background: #fafafa;
            border-left: 2px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            max-height: 100%;
        }

        #similar-seasons {
            padding: 12px;
            border-bottom: 2px solid #e0e0e0;
            flex-shrink: 0;
        }

        #similar-seasons h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 10px;
        }

        .similar-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 4px;
            border-radius: 6px;
            background: #fff;
            border: 1px solid #e8e8e8;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .similar-item:hover {
            background: #e8f5e9;
            border-color: #a5d6a7;
        }

        .similar-item .sim-percent {
            font-weight: 600;
            color: #2e7d32;
            margin-right: 8px;
            min-width: 40px;
        }

        .similar-item .sim-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #boot-track {
            flex: 1;
            padding: 12px;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        #boot-track h3 {
            text-align: center;
            margin-bottom: 12px;
            color: #d32f2f;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            flex-shrink: 0;
        }

        #boot-list {
            flex: 1;
            overflow-y: scroll;
            min-height: 0;
            padding-right: 4px;
        }

        /* Ensure scrollbar is always visible */
        #boot-list::-webkit-scrollbar {
            width: 8px;
        }

        #boot-list::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 4px;
        }

        #boot-list::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        #boot-list::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        .boot-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 4px;
            border-radius: 6px;
            background: #fff;
            border: 1px solid #e8e8e8;
            font-size: 12px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .boot-item:hover {
            background: #f0f7ff;
            border-color: #90caf9;
        }

        .boot-item .color-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
            flex-shrink: 0;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .boot-item .placement {
            color: #888;
            margin-right: 6px;
            font-size: 10px;
            min-width: 24px;
        }

        .boot-item .name {
            flex: 1;
            font-weight: 500;
        }

        .boot-item .tc-num {
            color: #999;
            font-size: 10px;
        }

        .boot-item.ftc-player {
            background: linear-gradient(135deg, #fff9e6 0%, #fff3cc 100%);
            border-color: #ffd54f;
        }

        .boot-item.ftc-player:hover {
            background: linear-gradient(135deg, #fff3cc 0%, #ffecb3 100%);
            border-color: #ffca28;
        }

        .boot-item.ftc-player .tc-num {
            color: #f9a825;
            font-weight: 600;
        }

        #header {
            padding: 10px 16px;
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        #header .header-left h1 {
            font-size: 20px;
            color: #d32f2f;
            font-weight: 600;
        }

        #header .subtitle {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }

        #controls {
            display: flex;
            gap: 10px;
        }

        #controls select, #controls button {
            padding: 8px 14px;
            background: #fff;
            border: 1px solid #ddd;
            color: #333;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        #controls select:hover, #controls button:hover {
            background: #f5f5f5;
            border-color: #bbb;
        }

        #tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        #tooltip.visible {
            opacity: 1;
        }

        #tooltip .title {
            font-weight: 600;
            margin-bottom: 6px;
            color: #222;
        }

        #tooltip .detail {
            color: #666;
            line-height: 1.4;
        }

        svg {
            width: 100%;
            height: 100%;
            background: #ffffff;
        }

        #svg-wrapper {
            position: relative;
            flex: 1;
            min-height: 650px;
        }

        .layer-label {
            fill: #888;
            font-size: 11px;
            text-anchor: middle;
            font-weight: 500;
        }

        .merge-line {
            stroke: #d32f2f;
            stroke-width: 2px;
            stroke-dasharray: 8, 4;
            opacity: 0.7;
        }

        .merge-label {
            fill: #d32f2f;
            font-size: 12px;
            text-anchor: middle;
            font-weight: bold;
        }

        .node circle {
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
            transition: stroke-width 0.2s, filter 0.2s;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));
        }

        .node circle:hover {
            stroke-width: 3px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .node text {
            fill: #fff;
            font-size: 11px;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .vote-link {
            fill: none;
            stroke-opacity: 0.6;
            stroke-width: 2px;
            transition: stroke-opacity 0.2s, stroke-width 0.2s;
        }

        .vote-link.highlighted {
            stroke-opacity: 1;
            stroke-width: 3px;
        }

        .vote-link.dimmed {
            stroke-opacity: 0.1;
        }

        .node.highlighted circle {
            stroke-width: 4px;
            filter: drop-shadow(0 0 8px rgba(0,0,0,0.4));
        }

        .node.dimmed circle {
            opacity: 0.25;
        }

        .node.dimmed text {
            opacity: 0.25;
        }

        .node.selected circle {
            stroke: #ff9800 !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 10px rgba(255, 152, 0, 0.6));
        }

        .boot-item.selected {
            background: #fff3e0 !important;
            border: 2px solid #ff9800 !important;
        }

        #instructions {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 9px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            z-index: 50;
            display: flex;
            gap: 14px;
            align-items: flex-start;
        }

        #instructions .instructions-title {
            font-size: 10px;
            font-weight: 600;
            white-space: nowrap;
            padding-top: 2px;
        }

        #instructions .instruction-group {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        #instructions .instruction-label {
            font-size: 9px;
            font-weight: 600;
            color: #555;
        }

        #instructions .instruction-item {
            line-height: 1.2;
            color: #666;
            white-space: nowrap;
        }

        #instructions .instruction-item::before {
            content: "→ ";
            color: #999;
        }

        #instructions h4 {
            font-size: 13px;
            color: #333;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #instructions .instruction-group {
            margin-bottom: 10px;
        }

        #instructions .instruction-group:last-child {
            margin-bottom: 0;
        }

        #instructions .instruction-label {
            font-weight: 600;
            color: #555;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        #instructions .instruction-item {
            color: #666;
            line-height: 1.6;
            padding-left: 12px;
            position: relative;
        }

        #instructions .instruction-item::before {
            content: "→";
            position: absolute;
            left: 0;
            color: #999;
        }

        #legend {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 9px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            z-index: 50;
        }

        #legend h4 {
            font-size: 10px;
            color: #333;
            margin-bottom: 4px;
        }

        #legend .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
        }

        #legend .legend-color {
            width: 16px;
            height: 3px;
            margin-right: 6px;
            border-radius: 2px;
        }

        #scroll-indicator {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(211, 47, 47, 0.9);
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            z-index: 50;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #scroll-indicator:hover {
            background: rgba(211, 47, 47, 1);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #888;
        }

        /* Analysis Tab Styles */
        #analysis-tab {
            padding: 30px;
            overflow-y: auto;
            background: #f5f5f5;
        }

        .analysis-section {
            background: #fff;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .analysis-section h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #f0f0f0;
        }

        .season-selectors {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .season-selector {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .season-selector label {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
        }

        .season-selector select {
            padding: 10px 14px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            min-width: 200px;
            cursor: pointer;
        }

        .comparison-results {
            margin-top: 20px;
        }

        .similarity-summary {
            display: flex;
            gap: 20px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .similarity-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px 20px;
            text-align: center;
            min-width: 150px;
        }

        .similarity-card .seasons {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }

        .similarity-card .percent {
            font-size: 28px;
            font-weight: 700;
            color: #2e7d32;
        }

        .similarity-card .percent.medium {
            color: #f57c00;
        }

        .similarity-card .percent.low {
            color: #d32f2f;
        }

        .voting-blocks-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
        }

        .voting-blocks-table th,
        .voting-blocks-table td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .voting-blocks-table th {
            background: #f8f9fa;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            color: #666;
        }

        .voting-blocks-table tr:hover {
            background: #f8f9fa;
        }

        .vote-block {
            display: inline-flex;
            gap: 4px;
        }

        .vote-block span {
            background: #e3f2fd;
            color: #1565c0;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        /* Common Blocks Section */
        .common-blocks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .voter-count-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
        }

        .voter-count-card h4 {
            font-size: 14px;
            color: #333;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .voter-count-card h4 .count {
            background: #d32f2f;
            color: #fff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

        .block-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .block-item:last-child {
            border-bottom: none;
        }

        .block-item .pattern {
            font-weight: 500;
        }

        .block-item .frequency {
            font-size: 12px;
            color: #666;
        }

        .no-data {
            color: #999;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }

        /* Player Identity Tab Styles */
        #identity-tab {
            padding: 30px;
            overflow-y: auto;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: calc(100vh - 50px);
        }

        .identity-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .identity-header {
            text-align: center;
            color: #fff;
            margin-bottom: 30px;
        }

        .identity-header h2 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .identity-header p {
            font-size: 16px;
            opacity: 0.9;
        }

        .identity-prompt {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .prompt-text {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            display: block;
            margin-bottom: 20px;
        }

        .identity-selectors {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            align-items: flex-end;
        }

        .identity-selector {
            flex: 1;
            min-width: 120px;
        }

        .identity-selector label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .identity-selector select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            background: #fff;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .identity-selector select:hover {
            border-color: #667eea;
        }

        .identity-selector select:focus {
            outline: none;
            border-color: #667eea;
        }

        .reset-filters-btn {
            padding: 10px 16px;
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            height: 42px;
        }

        .reset-filters-btn:hover {
            background: #e94560;
            border-color: #e94560;
            color: #fff;
        }

        .identity-main-content {
            display: flex;
            gap: 24px;
        }

        .identity-stats-panel {
            flex: 1;
            min-width: 0;
        }

        .identity-players-panel {
            width: 320px;
            flex-shrink: 0;
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            max-height: 600px;
        }

        .players-header {
            padding: 16px 20px;
            border-bottom: 2px solid #f0f0f0;
        }

        .players-header h3 {
            font-size: 18px;
            color: #333;
            margin: 0 0 4px 0;
        }

        .players-filter-info {
            font-size: 12px;
            color: #888;
        }

        .players-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 6px;
            background: #f8f9fa;
            transition: background 0.2s;
        }

        .player-item:hover {
            background: #e9ecef;
        }

        .player-item.winner {
            background: linear-gradient(135deg, #fff9e6 0%, #fff3cd 100%);
            border: 1px solid #ffc107;
        }

        .player-name {
            font-weight: 500;
            color: #333;
            font-size: 14px;
        }

        .player-season {
            font-size: 12px;
            color: #888;
            background: #e0e0e0;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .player-badges {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .player-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #e0e0e0;
            color: #666;
        }

        .player-badge.winner {
            background: #ffc107;
            color: #333;
        }

        #identity-results {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #f0f0f0;
        }

        .results-header h3 {
            font-size: 20px;
            color: #333;
            margin: 0;
        }

        .sample-size {
            font-size: 14px;
            color: #666;
            background: #f5f5f5;
            padding: 6px 12px;
            border-radius: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        .stat-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 16px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .stat-card:hover {
            background: #e9ecef;
        }

        .stat-card.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .stat-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 13px;
            color: #666;
            margin-bottom: 6px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #333;
            margin-bottom: 2px;
        }

        .stat-diff {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .stat-diff.positive {
            color: #2e7d32;
        }

        .stat-diff.negative {
            color: #d32f2f;
        }

        .stat-diff.neutral {
            color: #666;
        }

        .stat-expected {
            font-size: 11px;
            color: #888;
            margin-bottom: 10px;
        }

        .stat-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            position: relative;
            overflow: visible;
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .stat-bar-expected {
            position: absolute;
            top: -4px;
            width: 3px;
            height: 16px;
            background: #ff9800;
            border-radius: 2px;
            transition: left 0.5s ease;
        }

        .stat-card.above-expected .stat-value {
            color: #2e7d32;
        }

        .stat-card.below-expected .stat-value {
            color: #d32f2f;
        }

        .legend-note {
            margin-top: 20px;
            text-align: center;
            font-size: 12px;
            color: #888;
        }

        .legend-actual {
            color: #667eea;
            margin-right: 8px;
        }

        .legend-expected {
            color: #ff9800;
            font-weight: bold;
            margin: 0 8px;
        }

        @media (max-width: 900px) {
            .identity-main-content {
                flex-direction: column;
            }
            
            .identity-players-panel {
                width: 100%;
                max-height: 400px;
            }
        }

        /* Elimination Predictor Tab Styles */
        #predictor-tab {
            padding: 30px;
            overflow-y: auto;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: calc(100vh - 50px);
        }

        .predictor-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .predictor-header {
            text-align: center;
            color: #fff;
            margin-bottom: 30px;
        }

        .predictor-header h2 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .predictor-header p {
            font-size: 16px;
            opacity: 0.8;
        }

        .predictor-main {
            display: flex;
            gap: 24px;
        }

        .predictor-inputs-panel {
            flex: 1;
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-height: calc(100vh - 180px);
            overflow-y: auto;
        }

        .predictor-inputs-panel h3 {
            font-size: 20px;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e0e0e0;
        }

        .input-section {
            margin-bottom: 24px;
        }

        .input-section h4 {
            font-size: 14px;
            color: #666;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .input-group label {
            flex: 0 0 140px;
            font-size: 13px;
            color: #555;
        }

        .input-group input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
        }

        .input-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #e94560;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .input-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .input-group select {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 13px;
            background: #fff;
        }

        .range-value {
            flex: 0 0 50px;
            text-align: right;
            font-weight: 600;
            color: #e94560;
            font-size: 14px;
        }

        .checkbox-group {
            margin-bottom: 10px;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #555;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #e94560;
        }

        .predictor-results-panel {
            width: 380px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .prediction-result {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
        }

        .prediction-result h3 {
            font-size: 16px;
            color: #666;
            margin-bottom: 16px;
        }

        .probability-display {
            margin-bottom: 16px;
        }

        .probability-value {
            font-size: 56px;
            font-weight: 700;
            color: #e94560;
            line-height: 1;
        }

        .probability-label {
            font-size: 14px;
            color: #888;
            margin-top: 4px;
        }

        .probability-bar {
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .probability-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #ff9800, #e94560);
            border-radius: 6px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .risk-level {
            font-size: 14px;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
        }

        .risk-level.low {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .risk-level.medium {
            background: #fff3e0;
            color: #ef6c00;
        }

        .risk-level.high {
            background: #ffebee;
            color: #c62828;
        }

        .model-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
            color: #fff;
        }

        .model-info h3 {
            font-size: 14px;
            color: rgba(255,255,255,0.9);
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .model-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 16px;
        }

        .model-stat {
            display: flex;
            flex-direction: column;
            text-align: center;
            padding: 12px;
            background: rgba(255,255,255,0.15);
            border-radius: 12px;
            backdrop-filter: blur(4px);
        }

        .model-stat .stat-label {
            color: rgba(255,255,255,0.7);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .model-stat .stat-value {
            font-weight: 700;
            color: #fff;
            font-size: 15px;
            line-height: 1.3;
        }

        .model-note {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            font-style: italic;
            line-height: 1.5;
            text-align: center;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        .feature-importance {
            background: #fff;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            flex: 1;
            overflow-y: auto;
        }

        .feature-importance h3 {
            font-size: 16px;
            color: #333;
            margin-bottom: 12px;
        }

        .importance-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .importance-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .importance-item .feature-name {
            flex: 0 0 160px;
            font-size: 11px;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .importance-item .importance-bar-container {
            flex: 1;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
        }

        .importance-item .importance-bar {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            border-radius: 4px;
        }

        .importance-item .importance-value {
            flex: 0 0 40px;
            text-align: right;
            font-size: 11px;
            color: #888;
        }

        @media (max-width: 900px) {
            .predictor-main {
                flex-direction: column;
            }
            
            .predictor-results-panel {
                width: 100%;
            }
        }

        /* Mobile Warning Banner */
        .mobile-warning {
            display: none;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 8px 12px;
            margin: 8px;
            text-align: center;
        }

        .mobile-warning-title {
            font-size: 12px;
            font-weight: 600;
            color: #856404;
            margin-bottom: 2px;
        }

        .mobile-warning-text {
            font-size: 11px;
            color: #856404;
            line-height: 1.3;
        }

        /* Mobile styles */
        @media (max-width: 600px) {
            .mobile-warning {
                display: block;
            }

            .tab-nav {
                padding: 0 5px;
                gap: 4px;
            }

            .tab-dropdown {
                flex: 1;
                min-width: 0;
            }

            .tab-dropdown-btn {
                padding: 12px 8px;
                font-size: 12px;
                width: 100%;
                justify-content: center;
                min-height: 44px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            }

            .dropdown-arrow {
                font-size: 8px;
            }

            .dropdown-menu {
                left: 5px !important;
                right: 5px;
                width: auto !important;
                min-width: 0;
            }

            .dropdown-item {
                padding: 10px 12px;
                font-size: 13px;
            }

            .tab-btn {
                padding: 12px 16px;
                font-size: 13px;
            }
            
            #quiz-tab {
                padding: 12px;
            }
            
            .quiz-container {
                padding: 16px;
                border-radius: 12px;
            }
            
            .quiz-header h2 {
                font-size: 22px;
            }
            
            .quiz-header p {
                font-size: 14px;
            }
            
            .spoiler-note {
                font-size: 11px;
                padding: 6px 12px;
            }
            
            .quiz-question h3 {
                font-size: 18px;
            }
            
            .quiz-answer {
                padding: 14px 16px;
                font-size: 14px;
            }
            
            .quiz-navigation {
                margin-top: 20px;
                padding-top: 16px;
            }
            
            .winner-result {
                padding: 24px 16px;
            }
            
            .winner-name {
                font-size: 32px;
            }
            
            .match-percentage {
                font-size: 48px;
            }
            
            .winner-traits {
                gap: 6px;
            }
            
            .winner-trait {
                padding: 4px 10px;
                font-size: 11px;
            }
            
            .share-btn {
                padding: 14px 24px;
                font-size: 14px;
                min-width: 180px;
            }
            
            .spoiler-season-display {
                font-size: 20px !important;
            }
            
            .spoiler-btn {
                padding: 12px 20px;
                font-size: 14px;
            }
            
            #predictor-tab {
                padding: 16px;
            }
            
            .predictor-header h2 {
                font-size: 22px;
            }
            
            #identity-tab {
                padding: 16px;
            }
        }

        /* Winner Quiz Tab Styles */
        #quiz-tab {
            padding: 24px;
            max-width: 900px;
            margin: 0 auto;
            overflow-y: auto;
        }

        .quiz-container {
            background: #fff;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .quiz-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .quiz-header h2 {
            font-size: 28px;
            color: #333;
            margin-bottom: 8px;
        }

        .quiz-header p {
            color: #666;
            font-size: 16px;
        }

        .quiz-progress {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 32px;
        }

        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s;
        }

        .progress-dot.completed {
            background: #667eea;
        }

        .progress-dot.current {
            background: #667eea;
            transform: scale(1.3);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.2);
        }

        .quiz-question {
            text-align: center;
            margin-bottom: 24px;
        }

        .quiz-question h3 {
            font-size: 22px;
            color: #333;
            margin-bottom: 8px;
        }

        .question-number {
            font-size: 14px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .quiz-answers {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .quiz-answer {
            padding: 16px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            background: #fff;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            font-size: 15px;
            color: #444;
        }

        .quiz-answer:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .quiz-answer.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
        }

        .quiz-navigation {
            display: flex;
            justify-content: center;
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #eee;
        }

        .quiz-nav-btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quiz-nav-btn.prev {
            background: #f0f0f0;
            border: none;
            color: #666;
        }

        .quiz-nav-btn.prev:hover {
            background: #e0e0e0;
        }

        .quiz-nav-btn.prev:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Quiz Results */
        .quiz-results {
            text-align: center;
        }

        .quiz-results h3 {
            font-size: 18px;
            color: #888;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .winner-result {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px;
            padding: 32px;
            color: #fff;
            margin-bottom: 24px;
        }

        .winner-result .winner-name {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .winner-result .winner-season {
            font-size: 18px;
            opacity: 0.9;
            margin-bottom: 16px;
        }

        .winner-result .winner-occupation {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 16px;
        }

        .winner-result .match-percentage {
            font-size: 48px;
            font-weight: 700;
            margin: 16px 0;
        }

        .winner-result .match-label {
            font-size: 14px;
            opacity: 0.8;
        }

        .winner-traits {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-top: 16px;
        }

        .winner-trait {
            background: rgba(255,255,255,0.2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
        }

        .runner-ups {
            margin-top: 24px;
        }

        .runner-ups h4 {
            font-size: 14px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 16px;
        }

        .runner-up-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .runner-up-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #f8f8f8;
            border-radius: 8px;
        }

        .runner-up-item .name {
            font-weight: 600;
            color: #333;
        }

        .runner-up-item .season {
            font-size: 13px;
            color: #888;
        }

        .runner-up-item .match {
            font-weight: 600;
            color: #667eea;
        }

        .quiz-restart {
            margin-top: 24px;
        }

        .quiz-restart button {
            padding: 12px 32px;
            background: #f0f0f0;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quiz-restart button:hover {
            background: #e0e0e0;
        }

        /* Quiz intro */
        .quiz-intro {
            text-align: center;
            padding: 40px 20px;
        }

        .quiz-intro h2 {
            font-size: 32px;
            margin-bottom: 16px;
        }

        .quiz-intro p {
            font-size: 16px;
            color: #666;
            margin-bottom: 32px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }

        .quiz-start-btn {
            padding: 16px 48px;
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quiz-start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .spoiler-note {
            background: #f0f4ff;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            color: #667eea;
            margin-top: 12px;
            display: inline-block;
        }

        /* Spoiler check screen */
        .spoiler-check-content {
            text-align: center;
            padding: 40px 20px;
        }

        .spoiler-check-content h3 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #333;
        }

        .spoiler-check-content p {
            font-size: 16px;
            color: #555;
            margin-bottom: 8px;
        }

        .spoiler-season-display {
            font-size: 24px !important;
            font-weight: 700;
            color: #667eea !important;
            margin: 16px 0 24px 0 !important;
        }

        .spoiler-question {
            font-weight: 500;
            margin-bottom: 24px !important;
            color: #666 !important;
        }

        .spoiler-buttons {
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .spoiler-btn {
            padding: 14px 28px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .spoiler-btn.yes {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
        }

        .spoiler-btn.yes:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .spoiler-btn.no {
            background: #f0f0f0;
            color: #666;
        }

        .spoiler-btn.no:hover {
            background: #e0e0e0;
        }

        .spoiler-skip-count {
            margin-top: 20px;
            font-size: 13px;
            color: #888;
        }

        /* Share section */
        .share-section {
            margin-top: 28px;
            padding-top: 28px;
            border-top: 1px solid rgba(255,255,255,0.2);
            text-align: center;
        }

        .share-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 16px 32px;
            background: rgba(255,255,255,0.95);
            border: none;
            border-radius: 12px;
            color: #667eea;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 200px;
        }

        .share-btn:hover {
            background: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        }

        .share-btn.copied {
            background: #4CAF50;
            color: #fff;
        }

        .share-btn.copied:hover {
            background: #4CAF50;
            transform: none;
        }

        .share-btn-icon {
            font-size: 20px;
        }
    </style>
</head>
<body>
    <!-- Debug Panel -->
    <div id="debug-panel" style="position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.9); color: #0f0; font-family: monospace; font-size: 11px; padding: 10px; z-index: 999999; max-height: 150px; overflow-y: auto; border-top: 2px solid #0f0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
            <strong style="color: #0ff;">DEBUG LOG</strong>
            <button onclick="document.getElementById('debug-panel').style.display='none'" style="background: #f00; color: white; border: none; padding: 2px 8px; font-size: 10px; border-radius: 3px;">CLOSE</button>
        </div>
        <div id="debug-log" style="font-size: 10px; line-height: 1.3;"></div>
    </div>

    <!-- Tab Navigation -->
    <nav class="tab-nav">
        <div class="tab-dropdown">
            <button class="tab-dropdown-btn active" data-dropdown="personal-quizzes">
                👤 Personal Quizzes <span class="dropdown-arrow">▼</span>
            </button>
            <div class="dropdown-menu">
                <button class="dropdown-item active" data-tab="identity">📊 My Chances of Winning</button>
                <button class="dropdown-item" data-tab="quiz">🏆 Which Winner Are You?</button>
            </div>
        </div>

        <div class="tab-dropdown">
            <button class="tab-dropdown-btn" data-dropdown="simulations">
                🎲 Simulations <span class="dropdown-arrow">▼</span>
            </button>
            <div class="dropdown-menu">
                <button class="dropdown-item" data-tab="predictor">🎯 Elimination Predictor</button>
                <button class="dropdown-item" data-tab="simulation">🏝️ Season 50 Simulation</button>
            </div>
        </div>

        <div class="tab-dropdown">
            <button class="tab-dropdown-btn" data-dropdown="season-analysis">
                📊 Season Analysis <span class="dropdown-arrow">▼</span>
            </button>
            <div class="dropdown-menu">
                <button class="dropdown-item" data-tab="voteflow">📊 Vote Flow</button>
                <button class="dropdown-item" data-tab="analysis">🔬 Season Similarity</button>
            </div>
        </div>
    </nav>

    <!-- Vote Flow Tab -->
    <div id="voteflow-tab" class="tab-content">
        <!-- Mobile Warning -->
        <div class="mobile-warning">
            <div class="mobile-warning-title">📱 Mobile Notice</div>
            <div class="mobile-warning-text">
                The Vote Flow visualization is best viewed on a desktop or laptop browser for optimal rendering and interactivity.
            </div>
        </div>

        <div id="main-viz">
            <div id="header">
                <div class="header-left">
                    <h1>Survivor Voting Flow</h1>
                    <div class="subtitle">Season <span id="season-num">--</span> · <span id="castaway-count">--</span> castaways · <span id="tc-count">--</span> tribal councils</div>
                </div>
                <div id="controls">
                    <select id="season-select">
                        <option>Loading seasons...</option>
                    </select>
                    <button id="reset-zoom">Reset Zoom</button>
                </div>
            </div>
            <div id="svg-wrapper" style="position: relative; flex: 1; overflow: hidden;">
                <div id="tooltip"></div>
                <div id="instructions">
                    <div class="instructions-title">📖 How to Explore</div>
                    <div class="instruction-group">
                        <div class="instruction-label">Hover</div>
                        <div class="instruction-item">Start coin: see voting path</div>
                        <div class="instruction-item">Vote coin: see paths to it</div>
                    </div>
                    <div class="instruction-group">
                        <div class="instruction-label">Click</div>
                        <div class="instruction-item">Coin/Boot: lock view</div>
                        <div class="instruction-item">Background: clear</div>
                    </div>
                </div>
                <div id="legend">
                    <h4>Legend</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #e57373, #ffb74d, #fff176, #81c784);"></div>
                        <span>Vote line</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #d32f2f; height: 2px; border-top: 2px dashed #d32f2f;"></div>
                        <span>Merge</span>
                    </div>
                    <div class="legend-item">
                        <span style="margin-right: 6px;">💀</span>
                        <span>Eliminated</span>
                    </div>
                </div>
                <div id="scroll-indicator" onclick="document.getElementById('ftc-section').scrollIntoView({behavior: 'smooth'})">
                    ↓ Scroll for Final Tribal Council
                </div>
                <svg id="viz"></svg>
                <div class="loading" id="loading">Loading...</div>
            </div>
            
            <!-- FTC Section -->
            <div id="ftc-section">
                <h2>🏆 Final Tribal Council</h2>
                <div id="ftc-content">
                    <div class="no-data">Loading jury vote data...</div>
                </div>
            </div>
        </div>
        <div id="sidebar">
            <div id="similar-seasons">
                <h3>🎯 Similar Seasons</h3>
                <div id="similar-list">Loading...</div>
            </div>
            <div id="boot-track">
                <h3>🔥 Boot Order</h3>
                <div id="boot-list"></div>
            </div>
        </div>
    </div>

    <!-- Analysis Tab -->
    <div id="analysis-tab" class="tab-content">
        <div class="analysis-section">
            <h2>🔄 Season Comparison Tool</h2>
            <p style="color: #666; margin-bottom: 16px;">Compare voting block patterns across seasons. Select up to 3 seasons to see how their post-merge voting dynamics compare.</p>
            
            <div class="season-selectors">
                <div class="season-selector">
                    <label>Season 1</label>
                    <select id="compare-season-1">
                        <option value="">Select a season...</option>
                    </select>
                </div>
                <div class="season-selector">
                    <label>Season 2</label>
                    <select id="compare-season-2">
                        <option value="">Select a season...</option>
                    </select>
                </div>
                <div class="season-selector">
                    <label>Season 3 (Optional)</label>
                    <select id="compare-season-3">
                        <option value="">None</option>
                    </select>
                </div>
            </div>
            
            <div id="comparison-results" class="comparison-results">
                <div class="no-data">Select seasons above to compare voting patterns</div>
            </div>
        </div>

        <div class="analysis-section">
            <h2>📈 Most Common Voting Blocks</h2>
            <p style="color: #666; margin-bottom: 16px;">The most frequent voting split patterns at each stage of the game, based on number of voters.</p>
            
            <div id="common-blocks" class="common-blocks-grid">
                <div class="no-data">Loading voting block data...</div>
            </div>
        </div>
    </div>

    <!-- Player Identity Tab -->
    <div id="identity-tab" class="tab-content active">
        <div class="identity-container">
            <div class="identity-header">
                <h2>👤 Player Identity Analysis</h2>
                <p>Select your identity characteristics to see historical Survivor statistics for players like you.</p>
            </div>
            
            <div class="identity-prompt">
                <span class="prompt-text">I am a...</span>
                <div class="identity-selectors">
                    <div class="identity-selector">
                        <label>Gender</label>
                        <select id="identity-gender">
                            <option value="">Any</option>
                            <option value="Man">Man</option>
                            <option value="Woman">Woman</option>
                        </select>
                    </div>
                    <div class="identity-selector">
                        <label>Age</label>
                        <select id="identity-age">
                            <option value="">Any</option>
                            <option value="18-24">18-24</option>
                            <option value="25-29">25-29</option>
                            <option value="30-39">30-39</option>
                            <option value="40-49">40-49</option>
                            <option value="50+">50+</option>
                        </select>
                    </div>
                    <div class="identity-selector">
                        <label>Race</label>
                        <select id="identity-race">
                            <option value="">Any</option>
                            <option value="White">White</option>
                            <option value="Black">Black</option>
                            <option value="Asian">Asian</option>
                            <option value="Latino/Hispanic">Latino/Hispanic</option>
                        </select>
                    </div>
                    <div class="identity-selector">
                        <label>LGBTQ+</label>
                        <select id="identity-lgbtq">
                            <option value="">Any</option>
                            <option value="LGBTQ+">LGBTQ+</option>
                            <option value="Not LGBTQ+">Not LGBTQ+</option>
                        </select>
                    </div>
                    <div class="identity-selector">
                        <label>Occupation</label>
                        <select id="identity-collar">
                            <option value="">Any</option>
                            <option value="White collar">White Collar</option>
                            <option value="Blue collar">Blue Collar</option>
                            <option value="No collar">No Collar</option>
                        </select>
                    </div>
                    <div class="identity-selector">
                        <label>Personality</label>
                        <select id="identity-personality">
                            <option value="">Any</option>
                            <option value="Introvert">Introvert</option>
                            <option value="Extrovert">Extrovert</option>
                        </select>
                    </div>
                    <button id="identity-reset" class="reset-filters-btn">Reset Filters</button>
                </div>
            </div>
            
            <div class="identity-main-content">
                <div class="identity-stats-panel">
                    <div id="identity-results">
                        <div class="results-header">
                            <h3>Your Survivor Odds</h3>
                            <div class="sample-size">Based on <span id="sample-count">0</span> contestants</div>
                        </div>
                        
                        <div class="stats-grid">
                            <div class="stat-card" data-milestone="won">
                                <div class="stat-icon">🏆</div>
                                <div class="stat-label">Win the Game</div>
                                <div class="stat-value" id="stat-win">--</div>
                                <div class="stat-diff" id="diff-win">--</div>
                                <div class="stat-expected">Expected: <span id="expected-win">--</span></div>
                                <div class="stat-bar"><div class="stat-bar-fill" id="bar-win"></div><div class="stat-bar-expected" id="bar-expected-win"></div></div>
                            </div>
                            <div class="stat-card" data-milestone="made_ftc">
                                <div class="stat-icon">🔥</div>
                                <div class="stat-label">Make Final Tribal</div>
                                <div class="stat-value" id="stat-ftc">--</div>
                                <div class="stat-diff" id="diff-ftc">--</div>
                                <div class="stat-expected">Expected: <span id="expected-ftc">--</span></div>
                                <div class="stat-bar"><div class="stat-bar-fill" id="bar-ftc"></div><div class="stat-bar-expected" id="bar-expected-ftc"></div></div>
                            </div>
                            <div class="stat-card" data-milestone="made_merge">
                                <div class="stat-icon">🤝</div>
                                <div class="stat-label">Make the Merge</div>
                                <div class="stat-value" id="stat-merge">--</div>
                                <div class="stat-diff" id="diff-merge">--</div>
                                <div class="stat-expected">Expected: <span id="expected-merge">--</span></div>
                                <div class="stat-bar"><div class="stat-bar-fill" id="bar-merge"></div><div class="stat-bar-expected" id="bar-expected-merge"></div></div>
                            </div>
                            <div class="stat-card" data-milestone="found_advantage">
                                <div class="stat-icon">🗺️</div>
                                <div class="stat-label">Find an Idol/Advantage</div>
                                <div class="stat-value" id="stat-advantage">--</div>
                                <div class="stat-diff" id="diff-advantage">--</div>
                                <div class="stat-expected">Expected: <span id="expected-advantage">--</span></div>
                                <div class="stat-bar"><div class="stat-bar-fill" id="bar-advantage"></div><div class="stat-bar-expected" id="bar-expected-advantage"></div></div>
                            </div>
                            <div class="stat-card" data-milestone="won_individual_challenge">
                                <div class="stat-icon">💪</div>
                                <div class="stat-label">Win Individual Challenge</div>
                                <div class="stat-value" id="stat-challenge">--</div>
                                <div class="stat-diff" id="diff-challenge">--</div>
                                <div class="stat-expected">Expected: <span id="expected-challenge">--</span></div>
                                <div class="stat-bar"><div class="stat-bar-fill" id="bar-challenge"></div><div class="stat-bar-expected" id="bar-expected-challenge"></div></div>
                            </div>
                        </div>
                        
                        <div class="legend-note">
                            <span class="legend-actual">■</span> Actual % achieving milestone
                            <span class="legend-expected">|</span> Expected % (if proportional)
                            <br><small>Click a stat card to filter the players list</small>
                        </div>
                    </div>
                </div>
                
                <div class="identity-players-panel">
                    <div class="players-header">
                        <h3>Matching Players</h3>
                        <div class="players-filter-info" id="players-filter-info">All players</div>
                    </div>
                    <div class="players-list" id="players-list">
                        <!-- Players will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Elimination Predictor Tab -->
    <div id="predictor-tab" class="tab-content">
        <div class="predictor-container">
            <div class="predictor-header">
                <h2>🎯 Elimination Predictor</h2>
                <p>Configure a player's situation to predict their elimination probability at the next tribal council.</p>
            </div>
            
            <div class="predictor-main">
                <div class="predictor-inputs-panel">
                    <h3>Player Configuration</h3>
                    
                    <div class="input-section">
                        <h4>🎮 Game State</h4>
                        <div class="input-group">
                            <label>Players Remaining</label>
                            <input type="range" id="pred-players-remaining" min="3" max="13" value="8">
                            <span class="range-value" id="pred-players-remaining-val">8</span>
                        </div>
                        <div class="input-group">
                            <label>Day in Game</label>
                            <input type="range" id="pred-day" min="13" max="39" value="25">
                            <span class="range-value" id="pred-day-val">25</span>
                        </div>
                    </div>
                    
                    <div class="input-section">
                        <h4>📺 Confessionals (Prior Episodes)</h4>
                        <div class="input-group">
                            <label>Last Episode</label>
                            <input type="range" id="pred-conf-prev" min="0" max="15" value="3">
                            <span class="range-value" id="pred-conf-prev-val">3</span>
                        </div>
                        <div class="input-group">
                            <label>Last 3 Episodes</label>
                            <input type="range" id="pred-conf-3ep" min="0" max="30" value="8">
                            <span class="range-value" id="pred-conf-3ep-val">8</span>
                        </div>
                        <div class="input-group">
                            <label>Season Total</label>
                            <input type="range" id="pred-conf-total" min="0" max="80" value="20">
                            <span class="range-value" id="pred-conf-total-val">20</span>
                        </div>
                    </div>
                    
                    <div class="input-section">
                        <h4>🗳️ Votes Against (Prior Episodes)</h4>
                        <div class="input-group">
                            <label>Last Episode</label>
                            <input type="range" id="pred-votes-prev" min="0" max="10" value="0">
                            <span class="range-value" id="pred-votes-prev-val">0</span>
                        </div>
                        <div class="input-group">
                            <label>Last 3 Episodes</label>
                            <input type="range" id="pred-votes-3ep" min="0" max="12" value="0">
                            <span class="range-value" id="pred-votes-3ep-val">0</span>
                        </div>
                        <div class="input-group">
                            <label>Times Received Votes</label>
                            <input type="range" id="pred-times-votes" min="0" max="6" value="1">
                            <span class="range-value" id="pred-times-votes-val">1</span>
                        </div>
                    </div>
                    
                    <div class="input-section">
                        <h4>🎯 Voting Accuracy</h4>
                        <div class="input-group">
                            <label>Last 3 Episodes</label>
                            <input type="range" id="pred-accuracy-3ep" min="0" max="100" value="70">
                            <span class="range-value" id="pred-accuracy-3ep-val">70%</span>
                        </div>
                        <div class="input-group">
                            <label>Season Total</label>
                            <input type="range" id="pred-accuracy-total" min="0" max="100" value="75">
                            <span class="range-value" id="pred-accuracy-total-val">75%</span>
                        </div>
                    </div>
                    
                    <div class="input-section">
                        <h4>💪 Individual Challenge Wins</h4>
                        <div class="input-group">
                            <label>Last 3 Episodes</label>
                            <input type="range" id="pred-wins-3ep" min="0" max="4" value="0">
                            <span class="range-value" id="pred-wins-3ep-val">0</span>
                        </div>
                        <div class="input-group">
                            <label>Season Total</label>
                            <input type="range" id="pred-wins-total" min="0" max="6" value="0">
                            <span class="range-value" id="pred-wins-total-val">0</span>
                        </div>
                    </div>
                    
                    <div class="input-section">
                        <h4>🗺️ Advantages</h4>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="pred-has-idol"> Has Hidden Immunity Idol</label>
                        </div>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="pred-has-extra-vote"> Has Extra Vote</label>
                        </div>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="pred-has-steal-vote"> Has Steal-a-Vote</label>
                        </div>
                        <div class="input-group">
                            <label>Total Advantages in Play</label>
                            <input type="range" id="pred-adv-circulation" min="0" max="10" value="2">
                            <span class="range-value" id="pred-adv-circulation-val">2</span>
                        </div>
                    </div>
                    
                    <div class="input-section">
                        <h4>👤 Demographics</h4>
                        <div class="input-group">
                            <label>Gender</label>
                            <select id="pred-gender">
                                <option value="Female">Woman</option>
                                <option value="Male">Man</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>Age</label>
                            <input type="range" id="pred-age" min="18" max="65" value="30">
                            <span class="range-value" id="pred-age-val">30</span>
                        </div>
                    </div>
                </div>
                
                <div class="predictor-results-panel">
                    <div class="prediction-result">
                        <h3>Elimination Probability</h3>
                        <div class="probability-display">
                            <div class="probability-value" id="pred-probability">--</div>
                            <div class="probability-label">chance of elimination</div>
                        </div>
                        <div class="probability-bar">
                            <div class="probability-fill" id="pred-prob-fill"></div>
                        </div>
                        <div class="risk-level" id="pred-risk-level">Configure player to see prediction</div>
                    </div>
                    
                    <div class="model-info">
                        <h3>📊 About This Prediction</h3>
                        <div class="model-stats">
                            <div class="model-stat">
                                <span class="stat-label">Data Points</span>
                                <span class="stat-value">3,132</span>
                            </div>
                            <div class="model-stat">
                                <span class="stat-label">Seasons</span>
                                <span class="stat-value">1 – 49</span>
                            </div>
                            <div class="model-stat">
                                <span class="stat-label">vs Random</span>
                                <span class="stat-value">1.7× better</span>
                            </div>
                        </div>
                        <p class="model-note">Picks the right boot 22% of the time (vs 13% random). Survivor is unpredictable!</p>
                    </div>
                    
                    <div class="feature-importance">
                        <h3>What Matters Most</h3>
                        <div class="importance-list" id="importance-list">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Winner Quiz Tab -->
    <div id="quiz-tab" class="tab-content">
        <div class="quiz-container">
            <div class="quiz-header">
                <h2>🏆 Which Survivor Winner Are You?</h2>
                <p>Answer 10 questions to discover which of the 49 Survivor winners matches your personality and play style!</p>
                <div class="spoiler-note">🔒 Spoiler protection: You'll be asked before revealing any winner names</div>
            </div>
            
            <div id="quiz-content">
                <!-- Quiz intro -->
                <div class="quiz-intro" id="quiz-intro">
                    <h2>Ready to Find Your Winner?</h2>
                    <p>This quiz will analyze your strategic style, social game, and competitive nature to match you with your Survivor winner twin.</p>
                    <button class="quiz-start-btn" onclick="startQuiz()">Start Quiz</button>
                </div>
                
                <!-- Quiz questions (hidden initially) -->
                <div id="quiz-questions" style="display: none;">
                    <div class="quiz-progress" id="quiz-progress">
                        <!-- Progress dots generated by JS -->
                    </div>
                    
                    <div class="quiz-question" id="quiz-question">
                        <span class="question-number">Question 1 of 10</span>
                        <h3 id="question-text">Loading...</h3>
                    </div>
                    
                    <div class="quiz-answers" id="quiz-answers">
                        <!-- Answers generated by JS -->
                    </div>
                    
                    <div class="quiz-navigation">
                        <button class="quiz-nav-btn prev" id="quiz-prev" onclick="prevQuestion()" disabled>← Go Back</button>
                    </div>
                </div>
                
                <!-- Spoiler check (hidden initially) -->
                <div id="quiz-spoiler-check" style="display: none;">
                    <div class="spoiler-check-content">
                        <h3>🔒 Spoiler Check</h3>
                        <p>Your top match is the winner of</p>
                        <p class="spoiler-season-display">Season <span id="spoiler-season">X</span> (<span id="spoiler-season-name"></span>)</p>
                        <p class="spoiler-question">Are you okay with this spoiler?</p>
                        <div class="spoiler-buttons">
                            <button class="spoiler-btn yes" onclick="acceptSpoiler()">Yes, show me!</button>
                            <button class="spoiler-btn no" onclick="skipSpoiler()">No, try next match</button>
                        </div>
                        <div class="spoiler-skip-count" id="spoiler-skip-count"></div>
                    </div>
                </div>
                
                <!-- Quiz results (hidden initially) -->
                <div id="quiz-results" class="quiz-results" style="display: none;">
                    <h3>Your Survivor Winner Match</h3>
                    <div class="winner-result" id="winner-result">
                        <!-- Populated by JS -->
                    </div>
                    <div class="share-section">
                        <button class="share-btn" onclick="copyShareText()">
                            <span class="share-btn-icon">📋</span>
                            <span class="share-btn-text">Share Your Result</span>
                        </button>
                    </div>
                    <div class="quiz-restart">
                        <button onclick="restartQuiz()">Take Quiz Again</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Season 50 Simulation Tab -->
    <div id="simulation-tab" class="tab-content">
        <iframe src="data/run_simulation.html" style="width: 100%; height: calc(100vh - 50px); border: none;"></iframe>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            nodeRadius: 24,
            layerWidth: 140,
            verticalPadding: 70,
            headerOffset: 50,
            colors: {
                eliminationVote: '#e94560',
                regularVote: '#888'
            }
        };

        // State
        let currentData = null;
        let seasonsManifest = null;
        let similarityData = null;
        let identityData = null;
        let predictorModel = null;
        let allSeasonsData = {};
        let quizQuestions = null;
        let winnerData = null;
        let svg, g, zoom;
        let width, height;
        let allNodes = [];
        let selectedCastaways = new Set();
        let selectionMode = null;
        
        // Quiz state
        let quizCurrentQuestion = 0;
        let quizAnswers = [];
        let quizRankedWinners = [];
        let quizCurrentMatchIndex = 0;
        let quizSkipCount = 0;
        let quizFinalMatch = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', init);

        async function init() {
            setupTabs();
            setupSVG();
            setupZoom();
            setupEventListeners();
            
            await loadManifest();
            await loadSimilarityData();
            await loadIdentityData();
            await loadPredictorModel();
            await loadQuizData();
            
            const defaultSeason = seasonsManifest?.seasons[seasonsManifest.seasons.length - 1]?.id || 'us46';
            await loadSeason(defaultSeason);
            
            setupAnalysisTab();
            loadCommonBlocks();
            setupIdentityTab();
            setupPredictorTab();
        }

        // Tab functionality
        function setupTabs() {
            // Debug helper
            const log = (msg) => {
                const debugLog = document.getElementById('debug-log');
                if (debugLog) {
                    const time = new Date().toLocaleTimeString();
                    debugLog.innerHTML = `<div style="color: #0ff;">[${time}] ${msg}</div>` + debugLog.innerHTML;
                    // Keep only last 20 messages
                    const lines = debugLog.children;
                    while (lines.length > 20) {
                        debugLog.removeChild(lines[lines.length - 1]);
                    }
                }
            };

            log('🚀 setupTabs() called');

            // Handle dropdown toggles
            const buttons = document.querySelectorAll('.tab-dropdown-btn');
            log(`📍 Found ${buttons.length} dropdown buttons`);

            buttons.forEach((btn, index) => {
                log(`🔧 Attaching listener to button ${index}: ${btn.textContent.trim().substring(0, 20)}...`);

                // Use only click event - modern browsers synthesize click from tap on mobile
                btn.addEventListener('click', (e) => {
                    log(`🔥 CLICK fired on button ${index}!`);
                    log(`   Target: ${e.target.tagName} / ${e.target.className}`);

                    e.preventDefault();

                    const dropdown = btn.closest('.tab-dropdown');
                    const isOpen = dropdown.classList.contains('open');
                    log(`   Dropdown was: ${isOpen ? 'OPEN' : 'CLOSED'}`);

                    // Close all dropdowns
                    document.querySelectorAll('.tab-dropdown').forEach(d => d.classList.remove('open'));
                    log('   ✓ Closed all dropdowns');

                    // Toggle this dropdown
                    if (!isOpen) {
                        dropdown.classList.add('open');
                        log('   ✅ OPENED this dropdown!');

                        // Position dropdown menu below button (for fixed positioning)
                        const menu = dropdown.querySelector('.dropdown-menu');
                        const rect = btn.getBoundingClientRect();
                        const isMobile = window.innerWidth <= 600;

                        menu.style.top = (rect.bottom + 2) + 'px';

                        if (isMobile) {
                            // On mobile, make dropdown full width with margins
                            menu.style.left = '5px';
                            menu.style.right = '5px';
                            menu.style.width = 'auto';
                        } else {
                            menu.style.left = rect.left + 'px';
                            menu.style.right = 'auto';
                            menu.style.width = '';
                        }
                        log(`   📍 Positioned at top: ${menu.style.top}`);
                    } else {
                        log('   ➡️ Already open, so closed it');
                    }
                }, false);
            });

            // Handle dropdown item clicks
            document.querySelectorAll('.dropdown-item').forEach(item => {
                item.addEventListener('click', () => {
                    log(`📌 Dropdown item clicked: ${item.dataset.tab}`);
                    const tabId = item.dataset.tab;
                    window.location.hash = tabId;

                    // Close all dropdowns
                    document.querySelectorAll('.tab-dropdown').forEach(d => d.classList.remove('open'));
                });
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                const isButton = e.target.closest('.tab-dropdown-btn');
                log(`🌍 Global click - isButton: ${!!isButton}, target: ${e.target.tagName}`);

                // Don't close if clicking on a dropdown button or its children
                if (isButton) {
                    log('   ⏸️ Ignoring (button click)');
                    return;
                }

                log('   🚫 Closing all dropdowns (outside click)');
                document.querySelectorAll('.tab-dropdown').forEach(d => d.classList.remove('open'));
            });

            // Handle hash changes (including back/forward buttons)
            window.addEventListener('hashchange', () => {
                switchToTab(getTabFromHash());
            });

            // Switch to initial tab based on URL hash
            switchToTab(getTabFromHash());
        }

        function getTabFromHash() {
            const hash = window.location.hash.slice(1);
            const validTabs = ['voteflow', 'analysis', 'identity', 'predictor', 'quiz', 'simulation'];
            return validTabs.includes(hash) ? hash : 'identity';
        }

        function switchToTab(tabId) {
            // Update active dropdown items
            document.querySelectorAll('.dropdown-item').forEach(item => item.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            const item = document.querySelector(`.dropdown-item[data-tab="${tabId}"]`);
            if (item) {
                item.classList.add('active');

                // Update parent dropdown button active state
                const dropdown = item.closest('.tab-dropdown');
                document.querySelectorAll('.tab-dropdown-btn').forEach(btn => btn.classList.remove('active'));
                if (dropdown) {
                    const dropdownBtn = dropdown.querySelector('.tab-dropdown-btn');
                    if (dropdownBtn) dropdownBtn.classList.add('active');
                }
            }

            const content = document.getElementById(tabId + '-tab');
            if (content) content.classList.add('active');

            if (tabId === 'voteflow') {
                // Resize SVG when switching back
                setTimeout(() => {
                    const container = document.getElementById('svg-wrapper');
                    width = container.clientWidth;
                    height = container.clientHeight || 600;
                    svg.attr('width', width).attr('height', height);
                    if (currentData) render(currentData);
                }, 100);
            }
        }

        async function loadManifest() {
            try {
                const response = await fetch('data/seasons_manifest.json');
                if (!response.ok) throw new Error('Failed to load manifest');
                seasonsManifest = await response.json();
                populateSeasonDropdown();
            } catch (error) {
                console.error('Error loading manifest:', error);
                seasonsManifest = {
                    seasons: Array.from({length: 49}, (_, i) => ({
                        id: `us${String(i + 1).padStart(2, '0')}`,
                        name: `Season ${i + 1}`,
                        file: `us${String(i + 1).padStart(2, '0')}_voting_flow.json`
                    }))
                };
                populateSeasonDropdown();
            }
        }

        async function loadSimilarityData() {
            try {
                const response = await fetch('data/season_similarity.json');
                if (!response.ok) throw new Error('Failed to load similarity data');
                similarityData = await response.json();
            } catch (error) {
                console.error('Error loading similarity data:', error);
                similarityData = null;
            }
        }

        function populateSeasonDropdown() {
            const select = document.getElementById('season-select');
            select.innerHTML = '';
            
            const eras = [
                { name: '── New Era (41-49) ──', start: 41, end: 49 },
                { name: '── 30s (31-40) ──', start: 31, end: 40 },
                { name: '── 20s (21-30) ──', start: 21, end: 30 },
                { name: '── 10s (11-20) ──', start: 11, end: 20 },
                { name: '── Classic (1-10) ──', start: 1, end: 10 }
            ];
            
            eras.forEach(era => {
                const header = document.createElement('option');
                header.textContent = era.name;
                header.disabled = true;
                select.appendChild(header);
                
                const eraSeasons = seasonsManifest.seasons.filter(s => {
                    const num = parseInt(s.id.replace('us', ''));
                    return num >= era.start && num <= era.end;
                }).reverse();
                
                eraSeasons.forEach(season => {
                    const option = document.createElement('option');
                    option.value = season.id;
                    option.textContent = season.name;
                    select.appendChild(option);
                });
            });
        }

        function updateSimilarSeasons(seasonId) {
            const list = document.getElementById('similar-list');
            
            if (!similarityData) {
                list.innerHTML = '<div class="no-data">Similarity data not available</div>';
                return;
            }
            
            const seasonIdx = similarityData.seasons.indexOf(seasonId);
            if (seasonIdx === -1) {
                list.innerHTML = '<div class="no-data">No data for this season</div>';
                return;
            }
            
            // Get similarities for this season
            const similarities = [];
            similarityData.seasons.forEach((otherId, idx) => {
                if (idx !== seasonIdx) {
                    const sim = similarityData.similarity_matrix[seasonIdx][idx];
                    const otherSeason = seasonsManifest.seasons.find(s => s.id === otherId);
                    similarities.push({
                        id: otherId,
                        name: otherSeason ? otherSeason.name : otherId,
                        similarity: sim
                    });
                }
            });
            
            // Sort by similarity descending
            similarities.sort((a, b) => b.similarity - a.similarity);
            
            // Show top 5
            list.innerHTML = similarities.slice(0, 5).map(s => `
                <div class="similar-item" data-season="${s.id}">
                    <span class="sim-percent">${s.similarity.toFixed(0)}%</span>
                    <span class="sim-name">${s.name}</span>
                </div>
            `).join('');
            
            // Add click handlers
            list.querySelectorAll('.similar-item').forEach(item => {
                item.addEventListener('click', () => {
                    const sid = item.dataset.season;
                    document.getElementById('season-select').value = sid;
                    loadSeason(sid);
                });
            });
        }

        function setupSVG() {
            const container = document.getElementById('svg-wrapper');
            width = container.clientWidth;
            height = container.clientHeight || 600;

            svg = d3.select('#viz')
                .attr('width', width)
                .attr('height', height);

            g = svg.append('g');
        }

        function setupZoom() {
            zoom = d3.zoom()
                .scaleExtent([0.2, 3])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);
            
            svg.on('click', () => {
                selectedCastaways.clear();
                updateSelectionHighlights();
            });
        }

        function setupEventListeners() {
            document.getElementById('reset-zoom').addEventListener('click', resetZoom);
            document.getElementById('season-select').addEventListener('change', (e) => {
                loadSeason(e.target.value);
            });

            window.addEventListener('resize', () => {
                if (document.getElementById('voteflow-tab').classList.contains('active')) {
                    const container = document.getElementById('svg-wrapper');
                    width = container.clientWidth;
                    height = container.clientHeight || 600;
                    svg.attr('width', width).attr('height', height);
                    if (currentData) render(currentData);
                }
            });
        }

        function resetZoom() {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        }

        async function loadSeason(seasonId) {
            document.getElementById('loading').style.display = 'block';
            selectedCastaways.clear();
            selectionMode = null;
            
            try {
                const response = await fetch(`data/${seasonId}_voting_flow.json`);
                if (!response.ok) throw new Error('Failed to load data');
                currentData = await response.json();
                allSeasonsData[seasonId] = currentData;
                render(currentData);
                updateSimilarSeasons(seasonId);
                document.getElementById('season-select').value = seasonId;
            } catch (error) {
                console.error('Error loading season:', error);
                document.getElementById('loading').textContent = 'Error loading data.';
            }
        }

        function render(data) {
            document.getElementById('loading').style.display = 'none';
            
            document.getElementById('season-num').textContent = data.season;
            document.getElementById('castaway-count').textContent = data.total_castaways;
            document.getElementById('tc-count').textContent = data.total_tribal_councils;

            g.selectAll('*').remove();

            const { nodes, links, nodeMap } = buildGraph(data);
            allNodes = nodes;

            calculatePositions(nodes, data);

            const nodePositions = new Map();
            nodes.forEach(n => nodePositions.set(n.id, { x: n.x, y: n.y, layer: n.layer }));

            const mergeTC = data.tribal_councils.find(tc => tc.tribe_status === 'Merged');
            const mergeLayer = mergeTC ? data.tribal_councils.indexOf(mergeTC) + 1 : null;

            if (mergeLayer) {
                renderMergeLine(mergeLayer, data);
            }

            renderLinks(links, nodePositions, nodes);
            renderNodes(nodes);
            renderLayerLabels(data);
            renderBootTrack(data);
            renderFTC(data);

            fitToScreen(nodes);
        }

        function buildGraph(data) {
            const nodes = [];
            const links = [];
            const nodeMap = new Map();

            data.castaways.forEach((c, idx) => {
                const node = {
                    id: `${c.id}-L0`,
                    castawayId: c.id,
                    name: c.name,
                    color: c.color,
                    tribeColor: c.tribe_color,
                    layer: 0,
                    placement: c.placement,
                    isOriginal: true
                };
                nodes.push(node);
                nodeMap.set(node.id, node);
            });

            const currentPosition = new Map();
            data.castaways.forEach(c => currentPosition.set(c.id, `${c.id}-L0`));

            const eliminated = new Set();

            data.tribal_councils.forEach((tc, tcIdx) => {
                const layer = tcIdx + 1;
                const layerTargets = new Set();
                
                // Count votes for each target (only round 1)
                const voteCountByTarget = {};
                tc.votes.forEach(v => {
                    if (v.target_id && v.vote_round === 1) {
                        layerTargets.add(v.target_id);
                        voteCountByTarget[v.target_id] = (voteCountByTarget[v.target_id] || 0) + 1;
                    } else if (v.target_id) {
                        layerTargets.add(v.target_id);
                    }
                });

                layerTargets.forEach(targetId => {
                    const castaway = data.castaways.find(c => c.id === targetId);
                    if (!castaway) return;

                    const nodeId = `${targetId}-L${layer}`;
                    const node = {
                        id: nodeId,
                        castawayId: targetId,
                        name: castaway.name,
                        color: castaway.color,
                        tribeColor: castaway.tribe_color,
                        layer: layer,
                        placement: castaway.placement,
                        isTarget: true,
                        tcNumber: tc.tc_number,
                        isEliminated: tc.eliminated_id === targetId,
                        voteCount: voteCountByTarget[targetId] || 1
                    };
                    nodes.push(node);
                    nodeMap.set(node.id, node);
                });

                tc.votes.forEach(v => {
                    if (!v.target_id) return;
                    
                    const voterId = v.voter_id;
                    const targetId = v.target_id;

                    if (eliminated.has(voterId)) return;

                    const sourceNodeId = currentPosition.get(voterId);
                    const targetNodeId = `${targetId}-L${layer}`;

                    if (sourceNodeId && nodeMap.has(targetNodeId)) {
                        links.push({
                            source: sourceNodeId,
                            target: targetNodeId,
                            voter: v.voter,
                            voterId: voterId,
                            targetName: v.target,
                            targetId: targetId,
                            voterColor: v.voter_color,
                            voteRound: v.vote_round,
                            isEliminationVote: tc.eliminated_id === targetId,
                            tcNumber: tc.tc_number,
                            layer: layer
                        });

                        currentPosition.set(voterId, targetNodeId);
                    }
                });

                if (tc.eliminated_id) {
                    eliminated.add(tc.eliminated_id);
                }
            });

            return { nodes, links, nodeMap };
        }

        function calculatePositions(nodes, data) {
            const numLayers = data.total_tribal_councils + 1;
            const usableWidth = Math.max(width - 100, numLayers * CONFIG.layerWidth);
            const layerSpacing = usableWidth / (numLayers + 1);

            const layers = d3.group(nodes, d => d.layer);

            layers.forEach((layerNodes, layerIdx) => {
                const x = 80 + layerIdx * layerSpacing;
                const usableHeight = height - CONFIG.headerOffset - CONFIG.verticalPadding * 2;
                const nodeSpacing = usableHeight / (layerNodes.length + 1);

                layerNodes.sort((a, b) => (a.placement || 999) - (b.placement || 999));

                layerNodes.forEach((node, idx) => {
                    node.x = x;
                    node.y = CONFIG.headerOffset + CONFIG.verticalPadding + (idx + 1) * nodeSpacing;
                });
            });
        }

        function renderMergeLine(mergeLayer, data) {
            const numLayers = data.total_tribal_councils + 1;
            const usableWidth = Math.max(width - 100, numLayers * CONFIG.layerWidth);
            const layerSpacing = usableWidth / (numLayers + 1);
            
            const mergeX = 80 + (mergeLayer - 0.5) * layerSpacing;

            const mergeG = g.append('g').attr('class', 'merge-indicator');

            mergeG.append('line')
                .attr('class', 'merge-line')
                .attr('x1', mergeX)
                .attr('x2', mergeX)
                .attr('y1', CONFIG.headerOffset - 30)
                .attr('y2', height - 20);

            mergeG.append('text')
                .attr('class', 'merge-label')
                .attr('x', mergeX)
                .attr('y', CONFIG.headerOffset - 35)
                .text('MERGE');
        }

        function renderLinks(links, nodePositions, nodes) {
            const linkG = g.append('g').attr('class', 'links');

            const linkGroups = new Map();
            links.forEach((link, idx) => {
                const key = `${link.source}->${link.target}`;
                if (!linkGroups.has(key)) {
                    linkGroups.set(key, []);
                }
                linkGroups.get(key).push({ ...link, index: idx });
            });

            const linkOffsets = new Map();
            linkGroups.forEach((group, key) => {
                const count = group.length;
                group.forEach((link, i) => {
                    const offset = count === 1 ? 0 : (i - (count - 1) / 2) * 4;
                    linkOffsets.set(link.index, offset);
                });
            });

            linkG.selectAll('.vote-link')
                .data(links)
                .enter()
                .append('path')
                .attr('class', 'vote-link')
                .attr('d', (d, i) => {
                    const source = nodePositions.get(d.source);
                    const target = nodePositions.get(d.target);
                    if (!source || !target) return '';
                    
                    const offset = linkOffsets.get(i) || 0;
                    return createRoutedPath(source, target, offset);
                })
                .attr('stroke', d => d.voterColor)
                .attr('data-voter', d => d.voterId)
                .attr('data-target', d => d.targetId)
                .on('mouseover', handleLinkHover)
                .on('mouseout', handleLinkOut);
        }

        function createRoutedPath(source, target, offset = 0) {
            const x1 = source.x, y1 = source.y + offset;
            const x2 = target.x, y2 = target.y + offset;
            
            const midX = (x1 + x2) / 2;
            return `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
        }

        function renderNodes(nodes) {
            const nodeG = g.append('g').attr('class', 'nodes');
            
            // Calculate radius based on vote count
            // Start nodes: fixed size
            // Target nodes: scale from 0.5x to 1.2x based on votes (1 vote = small, 10+ votes = large)
            const getRadius = (d) => {
                if (d.isOriginal) return CONFIG.nodeRadius;
                const minScale = 0.5;
                const maxScale = 1.2;
                const voteCount = d.voteCount || 1;
                // Scale: 1 vote = minScale, 10 votes = maxScale
                const scale = minScale + (maxScale - minScale) * Math.min((voteCount - 1) / 9, 1);
                return CONFIG.nodeRadius * scale;
            };

            const nodeGroups = nodeG.selectAll('.node')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', d => `node ${d.isEliminated ? 'eliminated' : ''}`)
                .attr('id', d => `node-${d.id}`)
                .attr('transform', d => `translate(${d.x}, ${d.y})`)
                .on('mouseover', handleNodeHover)
                .on('mouseout', handleNodeOut)
                .on('click', handleNodeClick);

            nodeGroups.append('circle')
                .attr('r', d => getRadius(d))
                .attr('fill', d => d.color)
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5);

            nodeGroups.append('text')
                .attr('class', 'node-name')
                .attr('dy', '0.35em')
                .text(d => truncateName(d.name));

            nodeGroups.filter(d => d.isEliminated)
                .append('text')
                .attr('class', 'eliminated-indicator')
                .attr('x', d => getRadius(d) * 0.5)
                .attr('y', d => -getRadius(d) * 0.5)
                .attr('font-size', '10px')
                .text('💀');
        }

        function renderLayerLabels(data) {
            const numLayers = data.total_tribal_councils + 1;
            const usableWidth = Math.max(width - 100, numLayers * CONFIG.layerWidth);
            const layerSpacing = usableWidth / (numLayers + 1);

            // Calculate players remaining at each TC
            const labels = [{
                main: 'Start',
                sub: `${data.total_castaways} players`
            }];
            
            let playersRemaining = data.total_castaways;
            data.tribal_councils.forEach((tc, idx) => {
                // Count voters in round 1 to get players at this TC
                const votersAtTC = new Set(tc.votes.filter(v => v.vote_round === 1).map(v => v.voter_id)).size;
                labels.push({
                    main: `TC${tc.tc_number}`,
                    sub: votersAtTC > 0 ? `${votersAtTC} voting` : ''
                });
            });

            const labelG = g.append('g').attr('class', 'layer-labels');

            // Main labels
            labelG.selectAll('.layer-label')
                .data(labels)
                .enter()
                .append('text')
                .attr('class', 'layer-label')
                .attr('x', (d, i) => 80 + i * layerSpacing)
                .attr('y', CONFIG.headerOffset - 15)
                .text(d => d.main);
            
            // Sub labels (player count)
            labelG.selectAll('.layer-sublabel')
                .data(labels)
                .enter()
                .append('text')
                .attr('class', 'layer-label')
                .attr('x', (d, i) => 80 + i * layerSpacing)
                .attr('y', CONFIG.headerOffset)
                .attr('font-size', '9px')
                .attr('fill', '#999')
                .text(d => d.sub);
        }

        function renderBootTrack(data) {
            const bootList = document.getElementById('boot-list');
            bootList.innerHTML = '';

            data.boot_order.forEach(boot => {
                const item = document.createElement('div');
                item.className = 'boot-item' + (boot.elimination_type === 'FTC' ? ' ftc-player' : '');
                item.setAttribute('data-castaway', boot.id);
                
                // Display TC number or FTC for finalists
                const tcDisplay = boot.elimination_type === 'FTC' 
                    ? `FTC${boot.ftc_votes !== undefined ? ' (' + boot.ftc_votes + ')' : ''}`
                    : `TC${boot.tc_number}`;
                
                // Show crown for winner (placement 1 or highest FTC votes)
                const isWinner = boot.placement === 1 || (boot.elimination_type === 'FTC' && boot.ftc_votes === Math.max(...data.boot_order.filter(b => b.elimination_type === 'FTC').map(b => b.ftc_votes || 0)));
                const nameDisplay = isWinner && boot.elimination_type === 'FTC' ? `👑 ${boot.name}` : boot.name;
                
                item.innerHTML = `
                    <div class="color-dot" style="background: ${boot.color}"></div>
                    <span class="placement">#${boot.placement}</span>
                    <span class="name">${nameDisplay}</span>
                    <span class="tc-num">${tcDisplay}</span>
                `;
                item.addEventListener('mouseover', () => {
                    if (selectedCastaways.size === 0) {
                        highlightVotesReceived(boot.id);
                    }
                });
                item.addEventListener('mouseout', () => {
                    if (selectedCastaways.size === 0) {
                        clearHighlights();
                    }
                });
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (selectionMode && selectionMode !== 'votes-received') {
                        selectedCastaways.clear();
                    }
                    selectionMode = 'votes-received';
                    toggleSelection(boot.id);
                });
                bootList.appendChild(item);
            });
        }

        function renderFTC(data) {
            const container = document.getElementById('ftc-content');
            
            if (!data.ftc || !data.ftc.jury_votes || data.ftc.jury_votes.length === 0) {
                container.innerHTML = '<div class="no-data">No jury vote data available for this season</div>';
                return;
            }
            
            const ftc = data.ftc;
            const finalists = ftc.finalists || [];
            const juryVotes = ftc.jury_votes || [];
            
            // Find winner (most votes)
            const maxVotes = Math.max(...finalists.map(f => f.votes_received));
            
            // Build finalists cards
            let html = '<div class="ftc-finalists">';
            finalists.sort((a, b) => b.votes_received - a.votes_received).forEach(f => {
                const isWinner = f.votes_received === maxVotes && maxVotes > 0;
                html += `
                    <div class="finalist-card ${isWinner ? 'winner' : ''}">
                        <div class="finalist-color" style="background: ${f.color}"></div>
                        <div class="finalist-name">${f.name}</div>
                        <div class="finalist-votes">${f.votes_received} vote${f.votes_received !== 1 ? 's' : ''}</div>
                        ${isWinner ? '<div class="winner-badge">👑 WINNER</div>' : ''}
                    </div>
                `;
            });
            html += '</div>';
            
            // Build jury votes table
            html += `
                <div class="ftc-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Juror</th>
                                <th>Voted For</th>
                                <th>Voting Alignment</th>
                                <th>Eliminated By?</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            juryVotes.forEach(jv => {
                const alignmentClass = jv.alignment_pct === null ? '' : 
                    jv.alignment_pct >= 70 ? 'high' : 
                    jv.alignment_pct >= 40 ? 'medium' : 'low';
                
                const alignmentText = jv.alignment_pct === null ? '—' : 
                    `${jv.alignment_pct}% (${jv.aligned_votes}/${jv.eligible_votes})`;
                
                html += `
                    <tr>
                        <td>
                            <div class="juror-cell">
                                <div class="color-dot" style="background: ${jv.juror_color}"></div>
                                <span>${jv.juror_name}</span>
                            </div>
                        </td>
                        <td>
                            <div class="voted-for-cell">
                                <div class="color-dot" style="background: ${jv.voted_for_color}"></div>
                                <span>${jv.voted_for_name}</span>
                            </div>
                        </td>
                        <td class="alignment-cell ${alignmentClass}">${alignmentText}</td>
                        <td>
                            <span class="eliminated-by ${jv.finalist_helped_eliminate ? 'yes' : 'no'}">
                                ${jv.finalist_helped_eliminate ? '✗ Yes' : '✓ No'}
                            </span>
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table></div>';
            
            container.innerHTML = html;
        }

        function fitToScreen(nodes) {
            if (nodes.length === 0) return;

            const bounds = {
                minX: d3.min(nodes, d => d.x) - CONFIG.nodeRadius * 2,
                maxX: d3.max(nodes, d => d.x) + CONFIG.nodeRadius * 2,
                minY: d3.min(nodes, d => d.y) - CONFIG.nodeRadius * 2,
                maxY: d3.max(nodes, d => d.y) + CONFIG.nodeRadius * 2
            };

            const graphWidth = bounds.maxX - bounds.minX;
            const graphHeight = bounds.maxY - bounds.minY;

            const scale = Math.min(
                (width - 40) / graphWidth,
                (height - 40) / graphHeight,
                1
            ) * 0.9;

            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerY = (bounds.minY + bounds.maxY) / 2;

            const transform = d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(scale)
                .translate(-centerX, -centerY);

            svg.transition().duration(500).call(zoom.transform, transform);
        }

        function handleNodeHover(event, d) {
            if (selectedCastaways.size > 0) {
                if (d.isOriginal) {
                    showTooltip(event, {
                        title: d.name,
                        details: [`Click to ${selectedCastaways.has(d.castawayId) ? 'deselect' : 'select'}`]
                    });
                } else {
                    const tc = currentData.tribal_councils[d.tcNumber - 1];
                    const votesAgainst = tc.votes.filter(v => v.target_id === d.castawayId);
                    const voters = votesAgainst.map(v => v.voter);
                    const voteCount = votesAgainst.length;
                    
                    showTooltip(event, {
                        title: `${d.name} - TC${d.tcNumber}`,
                        details: [
                            `${voteCount} vote${voteCount !== 1 ? 's' : ''}: ${voters.join(', ')}`,
                            d.isEliminated ? '💀 Eliminated' : '✓ Survived'
                        ]
                    });
                }
                return;
            }

            if (d.isOriginal) {
                highlightVotesCast(d.castawayId);
                showTooltip(event, {
                    title: d.name,
                    details: [`Hover to see votes cast`, `Click to select`]
                });
            } else {
                highlightVoteTree(d.id);
                
                const tc = currentData.tribal_councils[d.tcNumber - 1];
                const votesAgainst = tc.votes.filter(v => v.target_id === d.castawayId);
                const voters = votesAgainst.map(v => v.voter);
                const voteCount = votesAgainst.length;
                
                showTooltip(event, {
                    title: `${d.name} - TC${d.tcNumber}`,
                    details: [
                        `${voteCount} vote${voteCount !== 1 ? 's' : ''}: ${voters.join(', ')}`,
                        d.isEliminated ? '💀 Eliminated' : '✓ Survived'
                    ]
                });
            }
        }

        function handleNodeOut() {
            hideTooltip();
            if (selectedCastaways.size === 0) {
                clearHighlights();
            }
        }

        function handleNodeClick(event, d) {
            event.stopPropagation();
            
            const newMode = d.isOriginal ? 'votes-cast' : 'votes-received';
            
            if (selectionMode && selectionMode !== newMode) {
                selectedCastaways.clear();
            }
            selectionMode = newMode;
            
            toggleSelection(d.castawayId);
        }

        function toggleSelection(castawayId) {
            if (selectedCastaways.has(castawayId)) {
                selectedCastaways.delete(castawayId);
                if (selectedCastaways.size === 0) {
                    selectionMode = null;
                }
            } else {
                selectedCastaways.add(castawayId);
            }
            updateSelectionHighlights();
        }

        function updateSelectionHighlights() {
            if (selectedCastaways.size === 0) {
                clearHighlights();
                g.selectAll('.node').classed('selected', false);
                document.querySelectorAll('.boot-item').forEach(item => {
                    item.classList.remove('selected');
                });
                selectionMode = null;
                return;
            }

            if (selectionMode === 'votes-cast') {
                g.selectAll('.node')
                    .classed('selected', d => selectedCastaways.has(d.castawayId) && d.isOriginal)
                    .classed('highlighted', d => selectedCastaways.has(d.castawayId) && d.isOriginal)
                    .classed('dimmed', d => !(selectedCastaways.has(d.castawayId) && d.isOriginal));

                g.selectAll('.vote-link')
                    .classed('highlighted', d => selectedCastaways.has(d.voterId))
                    .classed('dimmed', d => !selectedCastaways.has(d.voterId));

            } else if (selectionMode === 'votes-received') {
                g.selectAll('.node')
                    .classed('selected', d => selectedCastaways.has(d.castawayId))
                    .classed('highlighted', d => selectedCastaways.has(d.castawayId))
                    .classed('dimmed', d => !selectedCastaways.has(d.castawayId));

                g.selectAll('.vote-link')
                    .classed('highlighted', false)
                    .classed('dimmed', true);
            }

            document.querySelectorAll('.boot-item').forEach(item => {
                const id = item.getAttribute('data-castaway');
                item.classList.toggle('selected', selectedCastaways.has(id));
            });
        }

        function handleLinkHover(event, d) {
            showTooltip(event, {
                title: `${d.voter} → ${d.targetName}`,
                details: [
                    `TC${d.tcNumber}`,
                    d.voteRound > 1 ? `Revote round ${d.voteRound}` : '',
                    d.isEliminationVote ? '💀 Elimination vote' : ''
                ].filter(Boolean)
            });
            d3.select(event.target).classed('highlighted', true);
        }

        function handleLinkOut(event) {
            hideTooltip();
            d3.select(event.target).classed('highlighted', false);
        }

        function highlightVotesCast(castawayId) {
            const voterLinks = [];
            g.selectAll('.vote-link').each(function(d) {
                if (d.voterId === castawayId) {
                    voterLinks.push(d);
                }
            });

            const targetNodeIds = new Set(voterLinks.map(l => l.target));

            g.selectAll('.node')
                .classed('highlighted', d => {
                    if (d.castawayId === castawayId && d.isOriginal) return true;
                    if (targetNodeIds.has(d.id) && d.castawayId !== castawayId) return true;
                    return false;
                })
                .classed('dimmed', d => {
                    if (d.castawayId === castawayId && d.isOriginal) return false;
                    if (targetNodeIds.has(d.id) && d.castawayId !== castawayId) return false;
                    return true;
                });

            g.selectAll('.vote-link')
                .classed('highlighted', d => d.voterId === castawayId)
                .classed('dimmed', d => d.voterId !== castawayId);
        }

        function highlightVoteTree(targetNodeId) {
            const linksByTarget = new Map();
            const allLinks = [];
            
            g.selectAll('.vote-link').each(function(d) {
                allLinks.push(d);
                if (!linksByTarget.has(d.target)) {
                    linksByTarget.set(d.target, []);
                }
                linksByTarget.get(d.target).push(d);
            });

            const highlightedLinks = new Set();
            const highlightedNodes = new Set();
            const queue = [targetNodeId];
            
            highlightedNodes.add(targetNodeId);

            while (queue.length > 0) {
                const currentNodeId = queue.shift();
                const incomingLinks = linksByTarget.get(currentNodeId) || [];
                
                incomingLinks.forEach(link => {
                    highlightedLinks.add(link);
                    
                    if (!highlightedNodes.has(link.source)) {
                        highlightedNodes.add(link.source);
                        queue.push(link.source);
                    }
                });
            }

            g.selectAll('.node')
                .classed('highlighted', d => highlightedNodes.has(d.id))
                .classed('dimmed', d => !highlightedNodes.has(d.id));

            g.selectAll('.vote-link')
                .classed('highlighted', d => highlightedLinks.has(d))
                .classed('dimmed', d => !highlightedLinks.has(d));
        }

        function highlightVotesReceived(castawayId) {
            const incomingLinks = [];
            g.selectAll('.vote-link').each(function(d) {
                if (d.targetId === castawayId) {
                    incomingLinks.push(d);
                }
            });

            const voterIds = new Set(incomingLinks.map(l => l.voterId));

            g.selectAll('.node')
                .classed('highlighted', d => d.castawayId === castawayId || (d.isOriginal && voterIds.has(d.castawayId)))
                .classed('dimmed', d => d.castawayId !== castawayId && !(d.isOriginal && voterIds.has(d.castawayId)));

            g.selectAll('.vote-link')
                .classed('highlighted', d => d.targetId === castawayId)
                .classed('dimmed', d => d.targetId !== castawayId);

            document.querySelectorAll('.boot-item').forEach(item => {
                item.style.background = item.getAttribute('data-castaway') === castawayId 
                    ? 'rgba(233, 69, 96, 0.3)' 
                    : '';
            });
        }

        function clearHighlights() {
            g.selectAll('.node').classed('highlighted', false).classed('dimmed', false);
            g.selectAll('.vote-link').classed('highlighted', false).classed('dimmed', false);
            document.querySelectorAll('.boot-item').forEach(item => {
                if (!item.classList.contains('selected')) {
                    item.style.background = '';
                }
            });
        }

        function showTooltip(event, { title, details }) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="title">${title}</div>
                ${details.map(d => `<div class="detail">${d}</div>`).join('')}
            `;
            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function truncateName(name) {
            return name.length > 8 ? name.substring(0, 7) + '…' : name;
        }

        // ==================== ANALYSIS TAB ====================

        function setupAnalysisTab() {
            // Populate comparison dropdowns
            const selects = ['compare-season-1', 'compare-season-2', 'compare-season-3'];
            
            selects.forEach((selectId, idx) => {
                const select = document.getElementById(selectId);
                select.innerHTML = idx === 2 ? '<option value="">None</option>' : '<option value="">Select a season...</option>';
                
                seasonsManifest.seasons.forEach(season => {
                    const option = document.createElement('option');
                    option.value = season.id;
                    option.textContent = season.name;
                    select.appendChild(option);
                });
                
                select.addEventListener('change', updateComparison);
            });
        }

        async function updateComparison() {
            const s1 = document.getElementById('compare-season-1').value;
            const s2 = document.getElementById('compare-season-2').value;
            const s3 = document.getElementById('compare-season-3').value;
            
            const results = document.getElementById('comparison-results');
            
            if (!s1 || !s2) {
                results.innerHTML = '<div class="no-data">Select at least two seasons to compare</div>';
                return;
            }
            
            results.innerHTML = '<div class="no-data">Loading comparison...</div>';
            
            // Load season data if not cached
            const seasons = [s1, s2];
            if (s3) seasons.push(s3);
            
            for (const sid of seasons) {
                if (!allSeasonsData[sid]) {
                    try {
                        const response = await fetch(`data/${sid}_voting_flow.json`);
                        allSeasonsData[sid] = await response.json();
                    } catch (e) {
                        console.error(`Failed to load ${sid}`, e);
                    }
                }
            }
            
            renderComparison(seasons);
        }

        function renderComparison(seasonIds) {
            const results = document.getElementById('comparison-results');
            
            if (!similarityData) {
                results.innerHTML = '<div class="no-data">Similarity data not available</div>';
                return;
            }
            
            // Calculate similarity scores between pairs
            const pairs = [];
            for (let i = 0; i < seasonIds.length; i++) {
                for (let j = i + 1; j < seasonIds.length; j++) {
                    const idx1 = similarityData.seasons.indexOf(seasonIds[i]);
                    const idx2 = similarityData.seasons.indexOf(seasonIds[j]);
                    if (idx1 >= 0 && idx2 >= 0) {
                        pairs.push({
                            s1: seasonIds[i],
                            s2: seasonIds[j],
                            similarity: similarityData.similarity_matrix[idx1][idx2]
                        });
                    }
                }
            }
            
            // Get season names
            const getSeasonName = (id) => {
                const s = seasonsManifest.seasons.find(s => s.id === id);
                return s ? s.name.replace('Season ', 'S') : id;
            };
            
            // Build similarity cards
            let html = '<div class="similarity-summary">';
            pairs.forEach(p => {
                const simClass = p.similarity >= 80 ? '' : p.similarity >= 60 ? 'medium' : 'low';
                html += `
                    <div class="similarity-card">
                        <div class="seasons">${getSeasonName(p.s1)} vs ${getSeasonName(p.s2)}</div>
                        <div class="percent ${simClass}">${p.similarity.toFixed(0)}%</div>
                    </div>
                `;
            });
            html += '</div>';
            
            // Build voting blocks comparison table
            html += '<h3 style="margin: 20px 0 10px; font-size: 14px;">Voting Blocks by Voter Count</h3>';
            html += '<table class="voting-blocks-table"><thead><tr><th>Voters</th>';
            seasonIds.forEach(sid => {
                html += `<th>${getSeasonName(sid)}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Get voting blocks for each season
            const blocksBySeason = {};
            seasonIds.forEach(sid => {
                blocksBySeason[sid] = getVotingBlocksBySeason(sid);
            });
            
            // Find all voter counts across seasons
            const allVoterCounts = new Set();
            Object.values(blocksBySeason).forEach(blocks => {
                Object.keys(blocks).forEach(k => allVoterCounts.add(parseInt(k)));
            });
            
            // Sort descending
            const sortedCounts = Array.from(allVoterCounts).sort((a, b) => b - a);
            
            sortedCounts.forEach(count => {
                html += `<tr><td><strong>${count}</strong></td>`;
                seasonIds.forEach(sid => {
                    const blocks = blocksBySeason[sid][count];
                    if (blocks && blocks.length > 0) {
                        html += '<td><div class="vote-block">';
                        blocks.forEach(b => {
                            html += `<span>${b.join('-')}</span>`;
                        });
                        html += '</div></td>';
                    } else {
                        html += '<td style="color: #999;">—</td>';
                    }
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            results.innerHTML = html;
        }

        function getVotingBlocksBySeason(seasonId) {
            const data = allSeasonsData[seasonId];
            if (!data) return {};
            
            const blocksByVoterCount = {};
            
            data.tribal_councils.forEach(tc => {
                if (tc.tribe_status !== 'Merged') return;
                
                const votes = tc.votes.filter(v => v.vote_round === 1);
                if (votes.length === 0) return;
                
                const voteCounts = {};
                votes.forEach(v => {
                    voteCounts[v.target_id] = (voteCounts[v.target_id] || 0) + 1;
                });
                
                const blocks = Object.values(voteCounts).sort((a, b) => b - a);
                const numVoters = votes.length;
                
                if (!blocksByVoterCount[numVoters]) {
                    blocksByVoterCount[numVoters] = [];
                }
                blocksByVoterCount[numVoters].push(blocks);
            });
            
            return blocksByVoterCount;
        }

        async function loadCommonBlocks() {
            const container = document.getElementById('common-blocks');
            container.innerHTML = '<div class="no-data">Loading all seasons data...</div>';
            
            // Load all seasons
            const allBlocks = {}; // { voterCount: { pattern: count } }
            
            for (const season of seasonsManifest.seasons) {
                try {
                    if (!allSeasonsData[season.id]) {
                        const response = await fetch(`data/${season.file}`);
                        allSeasonsData[season.id] = await response.json();
                    }
                    
                    const data = allSeasonsData[season.id];
                    data.tribal_councils.forEach(tc => {
                        if (tc.tribe_status !== 'Merged') return;
                        
                        const votes = tc.votes.filter(v => v.vote_round === 1);
                        if (votes.length === 0) return;
                        
                        const voteCounts = {};
                        votes.forEach(v => {
                            voteCounts[v.target_id] = (voteCounts[v.target_id] || 0) + 1;
                        });
                        
                        const blocks = Object.values(voteCounts).sort((a, b) => b - a);
                        const numVoters = votes.length;
                        const pattern = blocks.join('-');
                        
                        if (!allBlocks[numVoters]) {
                            allBlocks[numVoters] = {};
                        }
                        allBlocks[numVoters][pattern] = (allBlocks[numVoters][pattern] || 0) + 1;
                    });
                } catch (e) {
                    console.error(`Failed to load ${season.id}`, e);
                }
            }
            
            // Render common blocks
            let html = '';
            const voterCounts = Object.keys(allBlocks).map(Number).sort((a, b) => b - a);
            
            voterCounts.forEach(count => {
                const patterns = allBlocks[count];
                const sorted = Object.entries(patterns)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5);
                
                const total = Object.values(patterns).reduce((a, b) => a + b, 0);
                
                html += `
                    <div class="voter-count-card">
                        <h4><span class="count">${count}</span> Voters</h4>
                `;
                
                sorted.forEach(([pattern, freq]) => {
                    const pct = ((freq / total) * 100).toFixed(0);
                    html += `
                        <div class="block-item">
                            <span class="pattern">${pattern}</span>
                            <span class="frequency">${freq}× (${pct}%)</span>
                        </div>
                    `;
                });
                
                html += '</div>';
            });
            
            container.innerHTML = html;
        }

        // Identity Tab Functions
        async function loadIdentityData() {
            try {
                const response = await fetch('data/identity_stats.json?v=' + Date.now());
                if (!response.ok) throw new Error('Failed to load identity data');
                identityData = await response.json();
            } catch (error) {
                console.error('Error loading identity data:', error);
            }
        }

        let selectedMilestone = null;
        let currentFilters = {};

        function setupIdentityTab() {
            if (!identityData) return;
            
            const selectors = ['gender', 'age', 'race', 'lgbtq', 'collar', 'personality'];
            selectors.forEach(sel => {
                const element = document.getElementById(`identity-${sel}`);
                if (element) {
                    element.addEventListener('change', updateIdentityStats);
                }
            });
            
            // Reset button handler
            const resetBtn = document.getElementById('identity-reset');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    selectors.forEach(sel => {
                        const element = document.getElementById(`identity-${sel}`);
                        if (element) element.value = '';
                    });
                    selectedMilestone = null;
                    document.querySelectorAll('.stat-card').forEach(c => c.classList.remove('selected'));
                    updateIdentityStats();
                });
            }
            
            // Add click handlers to stat cards for milestone filtering
            document.querySelectorAll('.stat-card[data-milestone]').forEach(card => {
                card.addEventListener('click', () => {
                    const milestone = card.dataset.milestone;
                    
                    // Toggle selection
                    if (selectedMilestone === milestone) {
                        selectedMilestone = null;
                        card.classList.remove('selected');
                    } else {
                        document.querySelectorAll('.stat-card').forEach(c => c.classList.remove('selected'));
                        selectedMilestone = milestone;
                        card.classList.add('selected');
                    }
                    
                    updatePlayersList();
                });
            });
            
            updateIdentityStats();
        }

        function updateIdentityStats() {
            if (!identityData) return;
            
            const gender = document.getElementById('identity-gender').value;
            const age = document.getElementById('identity-age').value;
            const race = document.getElementById('identity-race').value;
            const lgbtq = document.getElementById('identity-lgbtq').value;
            const collar = document.getElementById('identity-collar').value;
            const personality = document.getElementById('identity-personality').value;
            
            currentFilters = {};
            if (gender) currentFilters['gender'] = gender;
            if (age) currentFilters['age_bucket'] = age;
            if (race) currentFilters['race_cat'] = race;
            if (lgbtq) currentFilters['lgbtq'] = lgbtq;
            if (collar) currentFilters['collar'] = collar;
            if (personality) currentFilters['personality_cat'] = personality;
            
            const result = calculateIdentityStats(currentFilters);
            displayIdentityStats(result);
            updatePlayersList();
        }

        function calculateIdentityStats(filters) {
            const totals = identityData.totals;
            const players = identityData.players || [];
            
            // Filter players based on identity filters
            let filteredPlayers = players.filter(player => {
                for (const [key, value] of Object.entries(filters)) {
                    if (player[key] !== value) return false;
                }
                return true;
            });
            
            const n = filteredPlayers.length;
            if (n === 0 && Object.keys(filters).length > 0) {
                return null;
            }
            
            // If no filters, use all players
            if (Object.keys(filters).length === 0) {
                filteredPlayers = players;
            }
            
            const actualN = filteredPlayers.length;
            const representation = actualN / totals.contestants;
            
            // Map from UI milestone names to data field names
            const milestoneMapping = {
                'won': 'won',
                'made_ftc': 'made_ftc',
                'made_merge': 'made_merge',
                'found_advantage': 'found_advantage',
                'won_individual_challenge': 'won_individual_challenge'
            };
            
            const milestones = ['won', 'made_ftc', 'made_merge', 'found_advantage', 'won_individual_challenge'];
            const milestoneStats = {};
            
            milestones.forEach(m => {
                // Count how many in filtered group achieved this milestone
                const achieved = filteredPlayers.filter(p => p[m]).length;
                
                // Actual %: of this identity group, what % achieved milestone
                const actual_pct = (achieved / actualN) * 100;
                
                // Expected %: if proportional representation
                // Map to correct totals key
                const totalsKey = milestoneMapping[m] || m;
                const totalAchieved = totals[totalsKey];
                const expected_pct = (representation * totalAchieved / actualN) * 100;
                
                milestoneStats[m] = {
                    achieved: achieved,
                    actual_pct: actual_pct,
                    expected_pct: expected_pct,
                    diff: actual_pct - expected_pct
                };
            });
            
            return {
                sampleSize: actualN,
                representation: representation * 100,
                milestones: milestoneStats
            };
        }

        function displayIdentityStats(result) {
            if (!result) return;
            
            document.getElementById('sample-count').textContent = result.sampleSize.toLocaleString();
            
            const metricConfig = [
                { id: 'win', key: 'won' },
                { id: 'ftc', key: 'made_ftc' },
                { id: 'merge', key: 'made_merge' },
                { id: 'advantage', key: 'found_advantage' },
                { id: 'challenge', key: 'won_individual_challenge' }
            ];
            
            metricConfig.forEach(({ id, key }) => {
                const milestone = result.milestones[key];
                if (!milestone) return;
                
                const actual = milestone.actual_pct;
                const expected = milestone.expected_pct;
                const diff = milestone.diff;
                
                // Update main value - actual % of this identity achieving milestone
                document.getElementById(`stat-${id}`).textContent = `${actual.toFixed(1)}%`;
                
                // Update diff
                const sign = diff >= 0 ? '+' : '';
                const diffEl = document.getElementById(`diff-${id}`);
                diffEl.textContent = `${sign}${diff.toFixed(1)}% vs expected`;
                diffEl.className = 'stat-diff ' + (diff > 1 ? 'positive' : diff < -1 ? 'negative' : 'neutral');
                
                // Update expected text
                document.getElementById(`expected-${id}`).textContent = `${expected.toFixed(1)}%`;
                
                // Update bars - scale to max of actual/expected or 100
                const maxVal = Math.max(actual, expected, 10);
                const scale = 100 / maxVal;
                
                const barFill = document.getElementById(`bar-${id}`);
                const barExpected = document.getElementById(`bar-expected-${id}`);
                
                barFill.style.width = `${Math.min(actual * scale, 100)}%`;
                barExpected.style.left = `${Math.min(expected * scale, 100)}%`;
                
                // Color coding on card
                const card = barFill.closest('.stat-card');
                card.classList.remove('above-expected', 'below-expected');
                if (diff > 1) {
                    card.classList.add('above-expected');
                } else if (diff < -1) {
                    card.classList.add('below-expected');
                }
            });
        }

        function updatePlayersList() {
            if (!identityData || !identityData.players) return;
            
            const listEl = document.getElementById('players-list');
            const filterInfoEl = document.getElementById('players-filter-info');
            
            // Filter players based on identity filters
            let filteredPlayers = identityData.players.filter(player => {
                for (const [key, value] of Object.entries(currentFilters)) {
                    if (player[key] !== value) return false;
                }
                return true;
            });
            
            // Further filter by milestone if selected
            if (selectedMilestone) {
                filteredPlayers = filteredPlayers.filter(player => player[selectedMilestone]);
            }
            
            // Update filter info text
            const milestoneLabels = {
                'won': 'Winners',
                'made_ftc': 'Made FTC',
                'made_merge': 'Made Merge',
                'found_advantage': 'Found Idol/Advantage',
                'won_individual_challenge': 'Won Individual Challenge'
            };
            
            let filterText = filteredPlayers.length + ' players';
            if (selectedMilestone) {
                filterText += ` • ${milestoneLabels[selectedMilestone]}`;
            }
            filterInfoEl.textContent = filterText;
            
            // Build HTML for players list
            if (filteredPlayers.length === 0) {
                listEl.innerHTML = '<div class="no-players">No players match the selected criteria</div>';
                return;
            }
            
            let html = '';
            filteredPlayers.forEach(player => {
                const isWinner = player.won;
                html += `
                    <div class="player-item ${isWinner ? 'winner' : ''}">
                        <div>
                            <div class="player-name">${isWinner ? '👑 ' : ''}${player.name}</div>
                            <div class="player-badges">
                                ${player.won ? '<span class="player-badge winner">Winner</span>' : ''}
                                ${player.made_ftc && !player.won ? '<span class="player-badge">FTC</span>' : ''}
                                ${player.won_individual_challenge ? '<span class="player-badge">🏆 Ind. Challenge</span>' : ''}
                                ${player.found_advantage ? '<span class="player-badge">🗺️ Idol</span>' : ''}
                            </div>
                        </div>
                        <span class="player-season">S${player.season}</span>
                    </div>
                `;
            });
            
            listEl.innerHTML = html;
        }

        // ========== ELIMINATION PREDICTOR TAB ==========
        
        async function loadPredictorModel() {
            try {
                const response = await fetch('data/elimination_model_js.json?v=' + Date.now());
                predictorModel = await response.json();
                console.log('Predictor model loaded');
            } catch (error) {
                console.error('Error loading predictor model:', error);
            }
        }

        function setupPredictorTab() {
            if (!predictorModel) return;
            
            // Setup all slider inputs
            const sliders = [
                { id: 'pred-players-remaining', suffix: '' },
                { id: 'pred-day', suffix: '' },
                { id: 'pred-conf-prev', suffix: '' },
                { id: 'pred-conf-3ep', suffix: '' },
                { id: 'pred-conf-total', suffix: '' },
                { id: 'pred-votes-prev', suffix: '' },
                { id: 'pred-votes-3ep', suffix: '' },
                { id: 'pred-times-votes', suffix: '' },
                { id: 'pred-accuracy-3ep', suffix: '%' },
                { id: 'pred-accuracy-total', suffix: '%' },
                { id: 'pred-wins-3ep', suffix: '' },
                { id: 'pred-wins-total', suffix: '' },
                { id: 'pred-adv-circulation', suffix: '' },
                { id: 'pred-age', suffix: '' }
            ];
            
            sliders.forEach(({ id, suffix }) => {
                const slider = document.getElementById(id);
                const valueDisplay = document.getElementById(id + '-val');
                if (slider && valueDisplay) {
                    slider.addEventListener('input', () => {
                        valueDisplay.textContent = slider.value + suffix;
                        updatePrediction();
                    });
                }
            });
            
            // Setup checkboxes
            ['pred-has-idol', 'pred-has-extra-vote', 'pred-has-steal-vote'].forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', updatePrediction);
                }
            });
            
            // Setup select
            const genderSelect = document.getElementById('pred-gender');
            if (genderSelect) {
                genderSelect.addEventListener('change', updatePrediction);
            }
            
            // Display model info
            displayModelInfo();
            
            // Initial prediction
            updatePrediction();
        }

        function displayModelInfo() {
            if (!predictorModel) return;
            
            // Display feature importance
            const importanceList = document.getElementById('importance-list');
            const topFeatures = predictorModel.xgb_feature_importance
                .sort((a, b) => b.importance - a.importance)
                .slice(0, 12);
            
            const maxImportance = topFeatures[0].importance;
            
            const featureLabels = {
                'players_remaining': 'Players Left',
                'individual_wins_last_3_ep': 'Recent Challenge Wins',
                'has_idol': 'Has Idol',
                'individual_wins_cumulative': 'Total Challenge Wins',
                'individual_wins_last_2_ep': 'Challenge Wins (2 ep)',
                'voting_accuracy_last_3_ep': 'Voting Accuracy',
                'individual_wins_prev_ep': 'Last Challenge Win',
                'times_received_votes': 'Times Targeted',
                'age_bucket': 'Age Group',
                'age': 'Age',
                'voting_accuracy_prev_ep': 'Last Vote Accuracy',
                'votes_against_last_3_ep': 'Recent Votes Against',
                'day': 'Day in Game',
                'race_cat': 'Race',
                'voting_accuracy_last_2_ep': 'Vote Accuracy (2 ep)',
                'confessionals_cumulative': 'Total Confessionals',
                'season': 'Season Era',
                'votes_against_cumulative': 'Total Votes Against'
            };
            
            let html = '';
            topFeatures.forEach(f => {
                const label = featureLabels[f.feature] || f.feature;
                const width = (f.importance / maxImportance) * 100;
                html += `
                    <div class="importance-item">
                        <span class="feature-name" title="${f.feature}">${label}</span>
                        <div class="importance-bar-container">
                            <div class="importance-bar" style="width: ${width}%"></div>
                        </div>
                    </div>
                `;
            });
            importanceList.innerHTML = html;
        }

        function updatePrediction() {
            if (!predictorModel) return;
            
            // Gather all input values
            const playersRemaining = parseInt(document.getElementById('pred-players-remaining').value);
            const day = parseInt(document.getElementById('pred-day').value);
            const confPrev = parseInt(document.getElementById('pred-conf-prev').value);
            const conf3ep = parseInt(document.getElementById('pred-conf-3ep').value);
            const confTotal = parseInt(document.getElementById('pred-conf-total').value);
            const votesPrev = parseInt(document.getElementById('pred-votes-prev').value);
            const votes3ep = parseInt(document.getElementById('pred-votes-3ep').value);
            const timesVotes = parseInt(document.getElementById('pred-times-votes').value);
            const accuracy3ep = parseInt(document.getElementById('pred-accuracy-3ep').value) / 100;
            const accuracyTotal = parseInt(document.getElementById('pred-accuracy-total').value) / 100;
            const wins3ep = parseInt(document.getElementById('pred-wins-3ep').value);
            const winsTotal = parseInt(document.getElementById('pred-wins-total').value);
            const hasIdol = document.getElementById('pred-has-idol').checked ? 1 : 0;
            const hasExtraVote = document.getElementById('pred-has-extra-vote').checked ? 1 : 0;
            const hasStealVote = document.getElementById('pred-has-steal-vote').checked ? 1 : 0;
            const advCirculation = parseInt(document.getElementById('pred-adv-circulation').value);
            const gender = document.getElementById('pred-gender').value;
            const age = parseInt(document.getElementById('pred-age').value);
            
            // Determine age bucket
            let ageBucket;
            if (age <= 24) ageBucket = '18-24';
            else if (age <= 29) ageBucket = '25-29';
            else if (age <= 39) ageBucket = '30-39';
            else if (age <= 49) ageBucket = '40-49';
            else ageBucket = '50+';
            
            // Build feature vector (in the order expected by the model)
            const features = {
                'season': 45, // Use a recent season as default
                'confessionals_prev_ep': confPrev,
                'confessionals_last_2_ep': Math.round(confPrev * 1.5), // Estimate
                'confessionals_last_3_ep': conf3ep,
                'confessionals_cumulative': confTotal,
                'confessional_time_prev_ep': confPrev * 20, // Rough estimate
                'confessional_time_last_2_ep': confPrev * 35,
                'confessional_time_last_3_ep': conf3ep * 20,
                'confessional_time_cumulative': confTotal * 18,
                'votes_against_prev_ep': votesPrev,
                'votes_against_last_2_ep': Math.round(votesPrev * 1.3),
                'votes_against_last_3_ep': votes3ep,
                'votes_against_cumulative': Math.max(votes3ep, timesVotes * 2),
                'times_received_votes': timesVotes,
                'voting_accuracy_prev_ep': accuracy3ep, // Use 3ep as proxy
                'voting_accuracy_last_2_ep': accuracy3ep,
                'voting_accuracy_last_3_ep': accuracy3ep,
                'voting_accuracy_cumulative': accuracyTotal,
                'individual_wins_prev_ep': wins3ep > 0 ? 1 : 0,
                'individual_wins_last_2_ep': Math.min(wins3ep, 2),
                'individual_wins_last_3_ep': wins3ep,
                'individual_wins_cumulative': winsTotal,
                'num_tribe_swaps': 1, // Default
                'has_idol': hasIdol,
                'has_extra_vote': hasExtraVote,
                'has_steal_vote': hasStealVote,
                'has_block_vote': 0,
                'has_idol_nullifier': 0,
                'has_other_advantage': 0,
                'advantages_in_circulation': advCirculation,
                'players_remaining': playersRemaining,
                'day': day,
                'gender': predictorModel.label_encoders.gender[gender] || 0,
                'age': age,
                'age_bucket': predictorModel.label_encoders.age_bucket[ageBucket] || 2,
                'race_cat': predictorModel.label_encoders.race_cat['White'] || 0, // Default
                'collar': predictorModel.label_encoders.collar['Unknown'] || 0,
                'personality_type': 8 // Default middle value
            };
            
            // Calculate prediction using logistic regression
            let z = predictorModel.intercept;
            
            predictorModel.feature_order.forEach(feat => {
                const value = features[feat] !== undefined ? features[feat] : 0;
                const mean = predictorModel.scaler_mean[feat];
                const std = predictorModel.scaler_std[feat];
                const scaled = (value - mean) / std;
                const coef = predictorModel.coefficients[feat];
                z += scaled * coef;
            });
            
            // Sigmoid function
            const probability = 1 / (1 + Math.exp(-z));
            
            // Update display
            const probPercent = (probability * 100).toFixed(1);
            document.getElementById('pred-probability').textContent = probPercent + '%';
            document.getElementById('pred-prob-fill').style.width = probPercent + '%';
            
            // Update risk level
            const riskEl = document.getElementById('pred-risk-level');
            if (probability < 0.30) {
                riskEl.textContent = '🟢 Low Risk';
                riskEl.className = 'risk-level low';
            } else if (probability < 0.50) {
                riskEl.textContent = '🟡 Moderate Risk';
                riskEl.className = 'risk-level medium';
            } else {
                riskEl.textContent = '🔴 High Risk';
                riskEl.className = 'risk-level high';
            }
        }

        // ==================== QUIZ FUNCTIONS ====================
        
        async function loadQuizData() {
            try {
                const [questionsRes, winnersRes] = await Promise.all([
                    fetch('data/winner_quiz_questions.json?v=' + Date.now()),
                    fetch('data/winner_quiz_data.json?v=' + Date.now())
                ]);
                quizQuestions = await questionsRes.json();
                const winnerJson = await winnersRes.json();
                winnerData = winnerJson.winners;
                console.log('Quiz data loaded:', quizQuestions.length, 'questions,', winnerData.length, 'winners');
            } catch (error) {
                console.error('Failed to load quiz data:', error);
            }
        }

        function startQuiz() {
            quizCurrentQuestion = 0;
            quizAnswers = new Array(quizQuestions.length).fill(null);
            quizRankedWinners = [];
            quizCurrentMatchIndex = 0;
            quizSkipCount = 0;
            quizFinalMatch = null;
            
            document.getElementById('quiz-intro').style.display = 'none';
            document.getElementById('quiz-questions').style.display = 'block';
            document.getElementById('quiz-spoiler-check').style.display = 'none';
            document.getElementById('quiz-results').style.display = 'none';
            
            renderQuizProgress();
            renderQuizQuestion();
        }

        function renderQuizProgress() {
            const container = document.getElementById('quiz-progress');
            container.innerHTML = '';
            
            for (let i = 0; i < quizQuestions.length; i++) {
                const dot = document.createElement('div');
                dot.className = 'progress-dot';
                if (i < quizCurrentQuestion) dot.classList.add('completed');
                if (i === quizCurrentQuestion) dot.classList.add('current');
                container.appendChild(dot);
            }
        }

        function renderQuizQuestion() {
            const q = quizQuestions[quizCurrentQuestion];
            
            document.querySelector('.question-number').textContent = `Question ${quizCurrentQuestion + 1} of ${quizQuestions.length}`;
            document.getElementById('question-text').textContent = q.question;
            
            const answersContainer = document.getElementById('quiz-answers');
            answersContainer.innerHTML = '';
            
            q.answers.forEach((answer, idx) => {
                const btn = document.createElement('button');
                btn.className = 'quiz-answer';
                btn.textContent = answer.text;
                if (quizAnswers[quizCurrentQuestion] === idx) {
                    btn.classList.add('selected');
                }
                btn.addEventListener('click', () => selectAnswer(idx));
                answersContainer.appendChild(btn);
            });
            
            // Update back button
            document.getElementById('quiz-prev').disabled = quizCurrentQuestion === 0;
        }

        function selectAnswer(idx) {
            quizAnswers[quizCurrentQuestion] = idx;
            
            // Update UI
            document.querySelectorAll('.quiz-answer').forEach((btn, i) => {
                btn.classList.toggle('selected', i === idx);
            });
            
            // Auto-advance after a brief delay to show selection
            setTimeout(() => {
                if (quizCurrentQuestion < quizQuestions.length - 1) {
                    quizCurrentQuestion++;
                    renderQuizProgress();
                    renderQuizQuestion();
                } else {
                    finishQuiz();
                }
            }, 300);
        }

        function prevQuestion() {
            if (quizCurrentQuestion > 0) {
                quizCurrentQuestion--;
                renderQuizProgress();
                renderQuizQuestion();
            }
        }

        function calculateWinnerScores() {
            // Initialize scores for each winner
            const scores = winnerData.map(winner => ({
                winner: winner,
                score: 0,
                matchedTraits: []
            }));
            
            // Process each answer
            quizAnswers.forEach((answerIdx, questionIdx) => {
                if (answerIdx === null) return;
                
                const question = quizQuestions[questionIdx];
                const answer = question.answers[answerIdx];
                const weights = answer.weights;
                
                // Apply weights to each winner
                scores.forEach(entry => {
                    const winner = entry.winner;
                    
                    Object.entries(weights).forEach(([attr, weight]) => {
                        // Handle special categorical attributes
                        if (attr === 'collar') {
                            if (weight === 'any') {
                                entry.score += 0.5;
                            } else if (winner.collar === weight) {
                                entry.score += 1;
                                entry.matchedTraits.push(weight);
                            }
                        } else if (attr === 'times_played') {
                            const tp = winner.times_played;
                            if (weight === 'very_high' && tp >= 4) {
                                entry.score += 1;
                                entry.matchedTraits.push('Legend (4+ seasons)');
                            } else if (weight === 'high' && tp >= 3) {
                                entry.score += 1;
                                entry.matchedTraits.push('Returnee');
                            } else if (weight === 'low' && tp === 1) {
                                entry.score += 1;
                                entry.matchedTraits.push('One-timer');
                            } else if (weight === 'medium' && tp === 2) {
                                entry.score += 0.7;
                            }
                        } else if (attr === 'season_era') {
                            const s = winner.season;
                            if (weight === 'classic' && s <= 10) {
                                entry.score += 1;
                                entry.matchedTraits.push('Old School');
                            } else if (weight === 'middle' && s >= 11 && s <= 20) {
                                entry.score += 1;
                                entry.matchedTraits.push('Middle Era');
                            } else if (weight === 'modern' && s >= 21 && s <= 35) {
                                entry.score += 1;
                                entry.matchedTraits.push('Modern Era');
                            } else if (weight === 'new' && s >= 36) {
                                entry.score += 1;
                                entry.matchedTraits.push('New Era');
                            }
                        } else {
                            // Numerical attributes
                            const winnerValue = winner[attr] || 0;
                            let contribution;
                            if (weight > 0) {
                                contribution = winnerValue * weight;
                            } else {
                                contribution = (1 - winnerValue) * Math.abs(weight);
                            }
                            entry.score += contribution;
                        }
                    });
                });
            });
            
            // Normalize scores to percentages
            const maxScore = Math.max(...scores.map(s => s.score));
            scores.forEach(s => {
                s.percentage = maxScore > 0 ? (s.score / maxScore) * 100 : 0;
            });
            
            // Sort by score descending
            scores.sort((a, b) => b.score - a.score);
            
            return scores;
        }

        function finishQuiz() {
            // Calculate scores and store ranked winners
            quizRankedWinners = calculateWinnerScores();
            quizCurrentMatchIndex = 0;
            quizSkipCount = 0;
            
            // Show spoiler check for first match
            showSpoilerCheck();
        }

        function showSpoilerCheck() {
            const currentMatch = quizRankedWinners[quizCurrentMatchIndex];
            const winner = currentMatch.winner;
            
            document.getElementById('quiz-questions').style.display = 'none';
            document.getElementById('quiz-spoiler-check').style.display = 'block';
            document.getElementById('quiz-results').style.display = 'none';
            
            document.getElementById('spoiler-season').textContent = winner.season;
            document.getElementById('spoiler-season-name').textContent = winner.season_name || winner.season;
            
            // Show skip count if any skips
            const skipCountEl = document.getElementById('spoiler-skip-count');
            if (quizSkipCount > 0) {
                skipCountEl.textContent = `(${4 - quizSkipCount} skip${4 - quizSkipCount !== 1 ? 's' : ''} remaining)`;
            } else {
                skipCountEl.textContent = '';
            }
        }

        function acceptSpoiler() {
            quizFinalMatch = quizRankedWinners[quizCurrentMatchIndex];
            showQuizResults();
        }

        function skipSpoiler() {
            quizSkipCount++;
            quizCurrentMatchIndex++;
            
            // After 4 skips (5th time), give up and show current match
            if (quizSkipCount >= 4 || quizCurrentMatchIndex >= quizRankedWinners.length) {
                quizFinalMatch = quizRankedWinners[quizCurrentMatchIndex] || quizRankedWinners[quizRankedWinners.length - 1];
                showQuizResults();
            } else {
                showSpoilerCheck();
            }
        }

        function showQuizResults() {
            document.getElementById('quiz-spoiler-check').style.display = 'none';
            document.getElementById('quiz-results').style.display = 'block';
            
            const winner = quizFinalMatch.winner;
            const seasonDisplay = winner.season_name && winner.season_name !== String(winner.season) 
                ? `Season ${winner.season}: ${winner.season_name}`
                : `Season ${winner.season}`;
            
            // Build traits display
            const traits = [];
            if (winner.personality_type) {
                traits.push(winner.is_extrovert === 1 ? 'Extrovert' : 'Introvert');
            }
            if (winner.collar) traits.push(winner.collar);
            if (winner.times_played > 1) traits.push(`${winner.times_played}x Player`);
            if (winner.n_idols_found > 0) traits.push('Idol Finder');
            if (winner.score_jury >= 0.9) traits.push('Jury Favorite');
            if (winner.score_outplay_norm > 0.7) traits.push('Challenge Beast');
            if (winner.score_inf_norm > 0.7) traits.push('Strategic Leader');
            if (winner.n_votes_received === 0) traits.push('No Votes Received');
            
            // Render result
            document.getElementById('winner-result').innerHTML = `
                <div class="winner-name">${winner.name}</div>
                <div class="winner-season">${seasonDisplay}</div>
                <div class="winner-occupation">${winner.occupation || ''}</div>
                <div class="match-percentage">${Math.round(quizFinalMatch.percentage)}%</div>
                <div class="match-label">Match</div>
                <div class="winner-traits">
                    ${traits.slice(0, 5).map(t => `<span class="winner-trait">${t}</span>`).join('')}
                </div>
            `;
        }

        function copyShareText() {
            const winner = quizFinalMatch.winner;
            const matchRank = quizCurrentMatchIndex + 1;
            const rankSuffix = matchRank === 1 ? '' : ` (#${matchRank} match)`;
            const seasonName = winner.season_name && winner.season_name !== String(winner.season)
                ? ` (${winner.season_name})`
                : '';
            
            // Create share text (spoiler-free, text only like Wordle)
            const shareText = `🏆 Which Survivor Winner Are You?

I matched with the Season ${winner.season}${seasonName} Winner!${rankSuffix}
${Math.round(quizFinalMatch.percentage)}% Match

Take the quiz: .${window.location.href.split('?')[0].split('#')[0]}#quiz.`;

            const shareBtn = document.querySelector('.share-btn');
            
            // Function to show success state
            function showCopiedState() {
                shareBtn.innerHTML = '<span class="share-btn-icon">✓</span><span class="share-btn-text">Copied!</span>';
                shareBtn.classList.add('copied');
                
                setTimeout(() => {
                    shareBtn.innerHTML = '<span class="share-btn-icon">📋</span><span class="share-btn-text">Share Your Result</span>';
                    shareBtn.classList.remove('copied');
                }, 2500);
            }
            
            // Try modern clipboard API first, fallback to execCommand
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareText).then(() => {
                    showCopiedState();
                }).catch(err => {
                    // Fallback for when clipboard API fails (e.g., not HTTPS)
                    fallbackCopy(shareText, showCopiedState);
                });
            } else {
                fallbackCopy(shareText, showCopiedState);
            }
        }
        
        function fallbackCopy(text, onSuccess) {
            // Create temporary textarea
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            textArea.style.top = '-9999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    onSuccess();
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
            }
            
            document.body.removeChild(textArea);
        }

        function restartQuiz() {
            document.getElementById('quiz-results').style.display = 'none';
            document.getElementById('quiz-spoiler-check').style.display = 'none';
            document.getElementById('quiz-intro').style.display = 'block';
        }
    </script>
</body>
</html>
